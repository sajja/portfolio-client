{"version":3,"file":"index.js","sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/@use-gesture/core/dist/actions-8e12537b.esm.js","webpack:///./node_modules/@use-gesture/core/dist/maths-b2a210f4.esm.js","webpack:///./node_modules/@use-gesture/core/actions/dist/use-gesture-core-actions.esm.js","webpack:///./node_modules/@use-gesture/core/dist/use-gesture-core.esm.js","webpack:///./node_modules/@use-gesture/core/utils/dist/use-gesture-core-utils.esm.js","webpack:///./node_modules/@use-gesture/core/types/dist/use-gesture-core-types.esm.js","webpack:///./node_modules/@use-gesture/react/dist/use-gesture-react.esm.js","webpack:///./src/components/TextButton.scss?9052","webpack:///./src/components/IconButton.scss?8012","webpack:///./src/components/ImporterFrame.scss?9c61","webpack:///./src/components/file-step/FileSelector.scss?dd56","webpack:///./src/components/file-step/FormatErrorMessage.scss?898f","webpack:///./src/components/file-step/FormatRawPreview.scss?0237","webpack:///./src/components/file-step/FormatDataRowPreview.scss?bb3a","webpack:///./src/components/file-step/FileStep.scss?8c88","webpack:///./src/components/fields-step/ColumnDragCard.scss?0c54","webpack:///./src/components/fields-step/ColumnDragObject.scss?1da5","webpack:///./src/components/fields-step/ColumnDragSourceArea.scss?fdb8","webpack:///./src/components/fields-step/ColumnDragTargetArea.scss?aac4","webpack:///./src/components/ProgressDisplay.scss?6ad0","webpack:///./src/components/Importer.scss?f3ca","webpack:///./src/components/ImporterProps.ts","webpack:///./src/parser.ts","webpack:///./src/components/TextButton.tsx","webpack:///./src/components/IconButton.tsx","webpack:///./src/locale/locale_enUS.ts","webpack:///./src/locale/locale_deDE.ts","webpack:///./src/locale/locale_itIT.ts","webpack:///./src/locale/locale_ptBR.ts","webpack:///./src/locale/locale_daDK.ts","webpack:///./src/locale/locale_trTR.ts","webpack:///./src/locale/index.ts","webpack:///./src/locale/LocaleContext.tsx","webpack:///./src/components/ImporterFrame.tsx","webpack:///./src/components/file-step/FileSelector.tsx","webpack:///./src/components/file-step/FormatErrorMessage.tsx","webpack:///./src/components/file-step/FormatRawPreview.tsx","webpack:///./src/components/file-step/FormatDataRowPreview.tsx","webpack:///./src/components/file-step/FileStep.tsx","webpack:///./src/components/fields-step/ColumnPreview.tsx","webpack:///./src/components/fields-step/ColumnDragState.tsx","webpack:///./src/components/fields-step/ColumnDragCard.tsx","webpack:///./src/components/fields-step/ColumnDragObject.tsx","webpack:///./src/components/fields-step/ColumnDragSourceArea.tsx","webpack:///./src/components/fields-step/ColumnDragTargetArea.tsx","webpack:///./src/components/fields-step/FieldsStep.tsx","webpack:///./src/components/ProgressDisplay.tsx","webpack:///./src/components/ImporterField.tsx","webpack:///./src/components/Importer.tsx","webpack:///./src/index.ts"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 25);\n","import { V, c as computeRubberband } from './maths-b2a210f4.esm.js';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nconst EVENT_TYPE_MAP = {\n  pointer: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  mouse: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  touch: {\n    start: 'start',\n    change: 'move',\n    end: 'end'\n  },\n  gesture: {\n    start: 'start',\n    change: 'change',\n    end: 'end'\n  }\n};\n\nfunction capitalize(string) {\n  if (!string) return '';\n  return string[0].toUpperCase() + string.slice(1);\n}\n\nfunction toHandlerProp(device, action = '', capture = false) {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return 'on' + capitalize(device) + capitalize(actionKey) + (capture ? 'Capture' : '');\n}\nconst pointerCaptureEvents = ['gotpointercapture', 'lostpointercapture'];\nfunction parseProp(prop) {\n  let eventKey = prop.substring(2).toLowerCase();\n  const passive = !!~eventKey.indexOf('passive');\n  if (passive) eventKey = eventKey.replace('passive', '');\n  const captureKey = pointerCaptureEvents.includes(eventKey) ? 'capturecapture' : 'capture';\n  const capture = !!~eventKey.indexOf(captureKey);\n  if (capture) eventKey = eventKey.replace('capture', '');\n  return {\n    device: eventKey,\n    capture,\n    passive\n  };\n}\nfunction toDomEventType(device, action = '') {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return device + actionKey;\n}\nfunction isTouch(event) {\n  return 'touches' in event;\n}\nfunction getPointerType(event) {\n  if (isTouch(event)) return 'touch';\n  if ('pointerType' in event) return event.pointerType;\n  return 'mouse';\n}\n\nfunction getCurrentTargetTouchList(event) {\n  return Array.from(event.touches).filter(e => {\n    var _event$currentTarget, _event$currentTarget$;\n\n    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));\n  });\n}\n\nfunction getTouchList(event) {\n  return event.type === 'touchend' || event.type === 'touchcancel' ? event.changedTouches : event.targetTouches;\n}\n\nfunction getValueEvent(event) {\n  return isTouch(event) ? getTouchList(event)[0] : event;\n}\n\nfunction distanceAngle(P1, P2) {\n  const dx = P2.clientX - P1.clientX;\n  const dy = P2.clientY - P1.clientY;\n  const cx = (P2.clientX + P1.clientX) / 2;\n  const cy = (P2.clientY + P1.clientY) / 2;\n  const distance = Math.hypot(dx, dy);\n  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;\n  const origin = [cx, cy];\n  return {\n    angle,\n    distance,\n    origin\n  };\n}\nfunction touchIds(event) {\n  return getCurrentTargetTouchList(event).map(touch => touch.identifier);\n}\nfunction touchDistanceAngle(event, ids) {\n  const [P1, P2] = Array.from(event.touches).filter(touch => ids.includes(touch.identifier));\n  return distanceAngle(P1, P2);\n}\nfunction pointerId(event) {\n  const valueEvent = getValueEvent(event);\n  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;\n}\nfunction pointerValues(event) {\n  const valueEvent = getValueEvent(event);\n  return [valueEvent.clientX, valueEvent.clientY];\n}\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\nfunction wheelValues(event) {\n  let {\n    deltaX,\n    deltaY,\n    deltaMode\n  } = event;\n\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT;\n    deltaY *= LINE_HEIGHT;\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT;\n    deltaY *= PAGE_HEIGHT;\n  }\n\n  return [deltaX, deltaY];\n}\nfunction scrollValues(event) {\n  var _ref, _ref2;\n\n  const {\n    scrollX,\n    scrollY,\n    scrollLeft,\n    scrollTop\n  } = event.currentTarget;\n  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];\n}\nfunction getEventDetails(event) {\n  const payload = {};\n  if ('buttons' in event) payload.buttons = event.buttons;\n\n  if ('shiftKey' in event) {\n    const {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    } = event;\n    Object.assign(payload, {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    });\n  }\n\n  return payload;\n}\n\nfunction call(v, ...args) {\n  if (typeof v === 'function') {\n    return v(...args);\n  } else {\n    return v;\n  }\n}\nfunction noop() {}\nfunction chain(...fns) {\n  if (fns.length === 0) return noop;\n  if (fns.length === 1) return fns[0];\n  return function () {\n    let result;\n\n    for (const fn of fns) {\n      result = fn.apply(this, arguments) || result;\n    }\n\n    return result;\n  };\n}\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\n\nconst BEFORE_LAST_KINEMATICS_DELAY = 32;\nclass Engine {\n  constructor(ctrl, args, key) {\n    this.ctrl = ctrl;\n    this.args = args;\n    this.key = key;\n\n    if (!this.state) {\n      this.state = {};\n      this.computeValues([0, 0]);\n      this.computeInitial();\n      if (this.init) this.init();\n      this.reset();\n    }\n  }\n\n  get state() {\n    return this.ctrl.state[this.key];\n  }\n\n  set state(state) {\n    this.ctrl.state[this.key] = state;\n  }\n\n  get shared() {\n    return this.ctrl.state.shared;\n  }\n\n  get eventStore() {\n    return this.ctrl.gestureEventStores[this.key];\n  }\n\n  get timeoutStore() {\n    return this.ctrl.gestureTimeoutStores[this.key];\n  }\n\n  get config() {\n    return this.ctrl.config[this.key];\n  }\n\n  get sharedConfig() {\n    return this.ctrl.config.shared;\n  }\n\n  get handler() {\n    return this.ctrl.handlers[this.key];\n  }\n\n  reset() {\n    const {\n      state,\n      shared,\n      ingKey,\n      args\n    } = this;\n    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;\n    state._step = [false, false];\n    state.intentional = false;\n    state._movement = [0, 0];\n    state._distance = [0, 0];\n    state._direction = [0, 0];\n    state._delta = [0, 0];\n    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];\n    state.args = args;\n    state.axis = undefined;\n    state.memo = undefined;\n    state.elapsedTime = 0;\n    state.direction = [0, 0];\n    state.distance = [0, 0];\n    state.overflow = [0, 0];\n    state._movementBound = [false, false];\n    state.velocity = [0, 0];\n    state.movement = [0, 0];\n    state.delta = [0, 0];\n    state.timeStamp = 0;\n  }\n\n  start(event) {\n    const state = this.state;\n    const config = this.config;\n\n    if (!state._active) {\n      this.reset();\n      this.computeInitial();\n      state._active = true;\n      state.target = event.target;\n      state.currentTarget = event.currentTarget;\n      state.lastOffset = config.from ? call(config.from, state) : state.offset;\n      state.offset = state.lastOffset;\n    }\n\n    state.startTime = state.timeStamp = event.timeStamp;\n  }\n\n  computeValues(values) {\n    const state = this.state;\n    state._values = values;\n    state.values = this.config.transform(values);\n  }\n\n  computeInitial() {\n    const state = this.state;\n    state._initial = state._values;\n    state.initial = state.values;\n  }\n\n  compute(event) {\n    const {\n      state,\n      config,\n      shared\n    } = this;\n    state.args = this.args;\n    let dt = 0;\n\n    if (event) {\n      state.event = event;\n      if (config.preventDefault && event.cancelable) state.event.preventDefault();\n      state.type = event.type;\n      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;\n      shared.locked = !!document.pointerLockElement;\n      Object.assign(shared, getEventDetails(event));\n      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;\n      dt = event.timeStamp - state.timeStamp;\n      state.timeStamp = event.timeStamp;\n      state.elapsedTime = state.timeStamp - state.startTime;\n    }\n\n    if (state._active) {\n      const _absoluteDelta = state._delta.map(Math.abs);\n\n      V.addTo(state._distance, _absoluteDelta);\n    }\n\n    if (this.axisIntent) this.axisIntent(event);\n    const [_m0, _m1] = state._movement;\n    const [t0, t1] = config.threshold;\n    const {\n      _step,\n      values\n    } = state;\n\n    if (config.hasCustomTransform) {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];\n    } else {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;\n    }\n\n    state.intentional = _step[0] !== false || _step[1] !== false;\n    if (!state.intentional) return;\n    const movement = [0, 0];\n\n    if (config.hasCustomTransform) {\n      const [v0, v1] = values;\n      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;\n    } else {\n      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;\n    }\n\n    if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);\n    const previousOffset = state.offset;\n    const gestureIsActive = state._active && !state._blocked || state.active;\n\n    if (gestureIsActive) {\n      state.first = state._active && !state.active;\n      state.last = !state._active && state.active;\n      state.active = shared[this.ingKey] = state._active;\n\n      if (event) {\n        if (state.first) {\n          if ('bounds' in config) state._bounds = call(config.bounds, state);\n          if (this.setup) this.setup();\n        }\n\n        state.movement = movement;\n        this.computeOffset();\n      }\n    }\n\n    const [ox, oy] = state.offset;\n    const [[x0, x1], [y0, y1]] = state._bounds;\n    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];\n    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;\n    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;\n    const rubberband = state._active ? config.rubberband || [0, 0] : [0, 0];\n    state.offset = computeRubberband(state._bounds, state.offset, rubberband);\n    state.delta = V.sub(state.offset, previousOffset);\n    this.computeMovement();\n\n    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {\n      state.delta = V.sub(state.offset, previousOffset);\n      const absoluteDelta = state.delta.map(Math.abs);\n      V.addTo(state.distance, absoluteDelta);\n      state.direction = state.delta.map(Math.sign);\n      state._direction = state._delta.map(Math.sign);\n\n      if (!state.first && dt > 0) {\n        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];\n      }\n    }\n  }\n\n  emit() {\n    const state = this.state;\n    const shared = this.shared;\n    const config = this.config;\n    if (!state._active) this.clean();\n    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;\n    const memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {\n      [this.aliasKey]: state.values\n    }));\n    if (memo !== undefined) state.memo = memo;\n  }\n\n  clean() {\n    this.eventStore.clean();\n    this.timeoutStore.clean();\n  }\n\n}\n\nfunction selectAxis([dx, dy], threshold) {\n  const absDx = Math.abs(dx);\n  const absDy = Math.abs(dy);\n\n  if (absDx > absDy && absDx > threshold) {\n    return 'x';\n  }\n\n  if (absDy > absDx && absDy > threshold) {\n    return 'y';\n  }\n\n  return undefined;\n}\n\nclass CoordinatesEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"aliasKey\", 'xy');\n  }\n\n  reset() {\n    super.reset();\n    this.state.axis = undefined;\n  }\n\n  init() {\n    this.state.offset = [0, 0];\n    this.state.lastOffset = [0, 0];\n  }\n\n  computeOffset() {\n    this.state.offset = V.add(this.state.lastOffset, this.state.movement);\n  }\n\n  computeMovement() {\n    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);\n  }\n\n  axisIntent(event) {\n    const state = this.state;\n    const config = this.config;\n\n    if (!state.axis && event) {\n      const threshold = typeof config.axisThreshold === 'object' ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;\n      state.axis = selectAxis(state._movement, threshold);\n    }\n\n    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;\n  }\n\n  restrictToAxis(v) {\n    if (this.config.axis || this.config.lockDirection) {\n      switch (this.state.axis) {\n        case 'x':\n          v[1] = 0;\n          break;\n\n        case 'y':\n          v[0] = 0;\n          break;\n      }\n    }\n  }\n\n}\n\nconst identity = v => v;\nconst DEFAULT_RUBBERBAND = 0.15;\nconst commonConfigResolver = {\n  enabled(value = true) {\n    return value;\n  },\n\n  preventDefault(value = false) {\n    return value;\n  },\n\n  triggerAllEvents(value = false) {\n    return value;\n  },\n\n  rubberband(value = 0) {\n    switch (value) {\n      case true:\n        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];\n\n      case false:\n        return [0, 0];\n\n      default:\n        return V.toVector(value);\n    }\n  },\n\n  from(value) {\n    if (typeof value === 'function') return value;\n    if (value != null) return V.toVector(value);\n  },\n\n  transform(value, _k, config) {\n    const transform = value || config.shared.transform;\n    this.hasCustomTransform = !!transform;\n\n    if (process.env.NODE_ENV === 'development') {\n      const originalTransform = transform || identity;\n      return v => {\n        const r = originalTransform(v);\n\n        if (!isFinite(r[0]) || !isFinite(r[1])) {\n          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r[0]},${[1]}]`);\n        }\n\n        return r;\n      };\n    }\n\n    return transform || identity;\n  },\n\n  threshold(value) {\n    return V.toVector(value, 0);\n  }\n\n};\n\nif (process.env.NODE_ENV === 'development') {\n  Object.assign(commonConfigResolver, {\n    domTarget(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n      }\n\n      return NaN;\n    },\n\n    lockDirection(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`lockDirection\\` option has been merged with \\`axis\\`. Use it as in \\`{ axis: 'lock' }\\``);\n      }\n\n      return NaN;\n    },\n\n    initial(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`initial\\` option has been renamed to \\`from\\`.`);\n      }\n\n      return NaN;\n    }\n\n  });\n}\n\nconst DEFAULT_AXIS_THRESHOLD = 0;\nconst coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  axis(_v, _k, {\n    axis\n  }) {\n    this.lockDirection = axis === 'lock';\n    if (!this.lockDirection) return axis;\n  },\n\n  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {\n    return value;\n  },\n\n  bounds(value = {}) {\n    if (typeof value === 'function') {\n      return state => coordinatesConfigResolver.bounds(value(state));\n    }\n\n    if ('current' in value) {\n      return () => value.current;\n    }\n\n    if (typeof HTMLElement === 'function' && value instanceof HTMLElement) {\n      return value;\n    }\n\n    const {\n      left = -Infinity,\n      right = Infinity,\n      top = -Infinity,\n      bottom = Infinity\n    } = value;\n    return [[left, right], [top, bottom]];\n  }\n\n});\n\nconst DISPLACEMENT = 10;\nconst KEYS_DELTA_MAP = {\n  ArrowRight: (factor = 1) => [DISPLACEMENT * factor, 0],\n  ArrowLeft: (factor = 1) => [-DISPLACEMENT * factor, 0],\n  ArrowUp: (factor = 1) => [0, -DISPLACEMENT * factor],\n  ArrowDown: (factor = 1) => [0, DISPLACEMENT * factor]\n};\nclass DragEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'dragging');\n  }\n\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._pointerId = undefined;\n    state._pointerActive = false;\n    state._keyboardActive = false;\n    state._preventScroll = false;\n    state._delayed = false;\n    state.swipe = [0, 0];\n    state.tap = false;\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n  }\n\n  setup() {\n    const state = this.state;\n\n    if (state._bounds instanceof HTMLElement) {\n      const boundRect = state._bounds.getBoundingClientRect();\n\n      const targetRect = state.currentTarget.getBoundingClientRect();\n      const _bounds = {\n        left: boundRect.left - targetRect.left + state.offset[0],\n        right: boundRect.right - targetRect.right + state.offset[0],\n        top: boundRect.top - targetRect.top + state.offset[1],\n        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]\n      };\n      state._bounds = coordinatesConfigResolver.bounds(_bounds);\n    }\n  }\n\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    state.canceled = true;\n    state._active = false;\n    setTimeout(() => {\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n\n  setActive() {\n    this.state._active = this.state._pointerActive || this.state._keyboardActive;\n  }\n\n  clean() {\n    this.pointerClean();\n    this.state._pointerActive = false;\n    this.state._keyboardActive = false;\n    super.clean();\n  }\n\n  pointerDown(event) {\n    const config = this.config;\n    const state = this.state;\n    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons)) return;\n    this.ctrl.setEventIds(event);\n\n    if (config.pointerCapture) {\n      event.target.setPointerCapture(event.pointerId);\n    }\n\n    if (state._pointerActive) return;\n    this.start(event);\n    this.setupPointer(event);\n    state._pointerId = pointerId(event);\n    state._pointerActive = true;\n    this.computeValues(pointerValues(event));\n    this.computeInitial();\n\n    if (config.preventScrollAxis && getPointerType(event) !== 'mouse') {\n      state._active = false;\n      this.setupScrollPrevention(event);\n    } else if (config.delay > 0) {\n      this.setupDelayTrigger(event);\n\n      if (config.triggerAllEvents) {\n        this.compute(event);\n        this.emit();\n      }\n    } else {\n      this.startPointerDrag(event);\n    }\n  }\n\n  startPointerDrag(event) {\n    const state = this.state;\n    state._active = true;\n    state._preventScroll = true;\n    state._delayed = false;\n    this.compute(event);\n    this.emit();\n  }\n\n  pointerMove(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._pointerActive) return;\n    if (state.type === event.type && event.timeStamp === state.timeStamp) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n\n    const _values = pointerValues(event);\n\n    if (document.pointerLockElement === event.target) {\n      state._delta = [event.movementX, event.movementY];\n    } else {\n      state._delta = V.sub(_values, state._values);\n      this.computeValues(_values);\n    }\n\n    V.addTo(state._movement, state._delta);\n    this.compute(event);\n\n    if (state._delayed && state.intentional) {\n      this.timeoutStore.remove('dragDelay');\n      state.active = false;\n      this.startPointerDrag(event);\n      return;\n    }\n\n    if (config.preventScrollAxis && !state._preventScroll) {\n      if (state.axis) {\n        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === 'xy') {\n          state._active = false;\n          this.clean();\n          return;\n        } else {\n          this.timeoutStore.remove('startPointerDrag');\n          this.startPointerDrag(event);\n          return;\n        }\n      } else {\n        return;\n      }\n    }\n\n    this.emit();\n  }\n\n  pointerUp(event) {\n    this.ctrl.setEventIds(event);\n\n    try {\n      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {\n        ;\n        event.target.releasePointerCapture(event.pointerId);\n      }\n    } catch (_unused) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \\`@react-three/fiber\\`. \\n\\nPlease upgrade to the latest version.`);\n      }\n    }\n\n    const state = this.state;\n    const config = this.config;\n    if (!state._active || !state._pointerActive) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n    this.state._pointerActive = false;\n    this.setActive();\n    this.compute(event);\n    const [dx, dy] = state._distance;\n    state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;\n\n    if (state.tap && config.filterTaps) {\n      state._force = true;\n    } else {\n      const [dirx, diry] = state.direction;\n      const [vx, vy] = state.velocity;\n      const [mx, my] = state.movement;\n      const [svx, svy] = config.swipe.velocity;\n      const [sx, sy] = config.swipe.distance;\n      const sdt = config.swipe.duration;\n\n      if (state.elapsedTime < sdt) {\n        if (Math.abs(vx) > svx && Math.abs(mx) > sx) state.swipe[0] = dirx;\n        if (Math.abs(vy) > svy && Math.abs(my) > sy) state.swipe[1] = diry;\n      }\n    }\n\n    this.emit();\n  }\n\n  pointerClick(event) {\n    if (!this.state.tap) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n\n  setupPointer(event) {\n    const config = this.config;\n    const device = config.device;\n\n    if (process.env.NODE_ENV === 'development') {\n      try {\n        if (device === 'pointer' && config.preventScrollDelay === undefined) {\n          const currentTarget = 'uv' in event ? event.sourceEvent.currentTarget : event.currentTarget;\n          const style = window.getComputedStyle(currentTarget);\n\n          if (style.touchAction === 'auto') {\n            console.warn(`[@use-gesture]: The drag target has its \\`touch-action\\` style property set to \\`auto\\`. It is recommended to add \\`touch-action: 'none'\\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\\n\\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);\n          }\n        }\n      } catch (_unused2) {}\n    }\n\n    if (config.pointerLock) {\n      event.currentTarget.requestPointerLock();\n    }\n\n    if (!config.pointerCapture) {\n      this.eventStore.add(this.sharedConfig.window, device, 'change', this.pointerMove.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'end', this.pointerUp.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'cancel', this.pointerUp.bind(this));\n    }\n  }\n\n  pointerClean() {\n    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {\n      document.exitPointerLock();\n    }\n  }\n\n  preventScroll(event) {\n    if (this.state._preventScroll && event.cancelable) {\n      event.preventDefault();\n    }\n  }\n\n  setupScrollPrevention(event) {\n    persistEvent(event);\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'change', this.preventScroll.bind(this), {\n      passive: false\n    });\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'end', this.clean.bind(this));\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'cancel', this.clean.bind(this));\n    this.timeoutStore.add('startPointerDrag', this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);\n  }\n\n  setupDelayTrigger(event) {\n    this.state._delayed = true;\n    this.timeoutStore.add('dragDelay', () => {\n      this.state._step = [0, 0];\n      this.startPointerDrag(event);\n    }, this.config.delay);\n  }\n\n  keyDown(event) {\n    const deltaFn = KEYS_DELTA_MAP[event.key];\n\n    if (deltaFn) {\n      const state = this.state;\n      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;\n      state._delta = deltaFn(factor);\n      this.start(event);\n      state._keyboardActive = true;\n      V.addTo(state._movement, state._delta);\n      this.compute(event);\n      this.emit();\n    }\n  }\n\n  keyUp(event) {\n    if (!(event.key in KEYS_DELTA_MAP)) return;\n    this.state._keyboardActive = false;\n    this.setActive();\n    this.compute(event);\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    const device = this.config.device;\n    bindFunction(device, 'start', this.pointerDown.bind(this));\n\n    if (this.config.pointerCapture) {\n      bindFunction(device, 'change', this.pointerMove.bind(this));\n      bindFunction(device, 'end', this.pointerUp.bind(this));\n      bindFunction(device, 'cancel', this.pointerUp.bind(this));\n      bindFunction('lostPointerCapture', '', this.pointerUp.bind(this));\n    }\n\n    bindFunction('key', 'down', this.keyDown.bind(this));\n    bindFunction('key', 'up', this.keyUp.bind(this));\n\n    if (this.config.filterTaps) {\n      bindFunction('click', '', this.pointerClick.bind(this), {\n        capture: true,\n        passive: false\n      });\n    }\n  }\n\n}\n\nfunction persistEvent(event) {\n  'persist' in event && typeof event.persist === 'function' && event.persist();\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;\n\nfunction supportsTouchEvents() {\n  return isBrowser && 'ontouchstart' in window;\n}\n\nfunction isTouchScreen() {\n  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;\n}\n\nfunction supportsPointerEvents() {\n  return isBrowser && 'onpointerdown' in window;\n}\n\nfunction supportsPointerLock() {\n  return isBrowser && 'exitPointerLock' in window.document;\n}\n\nfunction supportsGestureEvents() {\n  try {\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\n\nconst SUPPORT = {\n  isBrowser,\n  gesture: supportsGestureEvents(),\n  touch: isTouchScreen(),\n  touchscreen: isTouchScreen(),\n  pointer: supportsPointerEvents(),\n  pointerLock: supportsPointerLock()\n};\n\nconst DEFAULT_PREVENT_SCROLL_DELAY = 250;\nconst DEFAULT_DRAG_DELAY = 180;\nconst DEFAULT_SWIPE_VELOCITY = 0.5;\nconst DEFAULT_SWIPE_DISTANCE = 50;\nconst DEFAULT_SWIPE_DURATION = 250;\nconst DEFAULT_DRAG_AXIS_THRESHOLD = {\n  mouse: 0,\n  touch: 0,\n  pen: 8\n};\nconst dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  device(_v, _k, {\n    pointer: {\n      touch = false,\n      lock = false,\n      mouse = false\n    } = {}\n  }) {\n    this.pointerLock = lock && SUPPORT.pointerLock;\n    if (SUPPORT.touch && touch) return 'touch';\n    if (this.pointerLock) return 'mouse';\n    if (SUPPORT.pointer && !mouse) return 'pointer';\n    if (SUPPORT.touch) return 'touch';\n    return 'mouse';\n  },\n\n  preventScrollAxis(value, _k, {\n    preventScroll\n  }) {\n    this.preventScrollDelay = typeof preventScroll === 'number' ? preventScroll : preventScroll || preventScroll === undefined && value ? DEFAULT_PREVENT_SCROLL_DELAY : undefined;\n    if (!SUPPORT.touchscreen || preventScroll === false) return undefined;\n    return value ? value : preventScroll !== undefined ? 'y' : undefined;\n  },\n\n  pointerCapture(_v, _k, {\n    pointer: {\n      capture = true,\n      buttons = 1\n    } = {}\n  }) {\n    this.pointerButtons = buttons;\n    return !this.pointerLock && this.device === 'pointer' && capture;\n  },\n\n  threshold(value, _k, {\n    filterTaps = false,\n    tapsThreshold = 3,\n    axis = undefined\n  }) {\n    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);\n    this.filterTaps = filterTaps;\n    this.tapsThreshold = tapsThreshold;\n    return threshold;\n  },\n\n  swipe({\n    velocity = DEFAULT_SWIPE_VELOCITY,\n    distance = DEFAULT_SWIPE_DISTANCE,\n    duration = DEFAULT_SWIPE_DURATION\n  } = {}) {\n    return {\n      velocity: this.transform(V.toVector(velocity)),\n      distance: this.transform(V.toVector(distance)),\n      duration\n    };\n  },\n\n  delay(value = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n\n      case false:\n        return 0;\n\n      default:\n        return value;\n    }\n  },\n\n  axisThreshold(value) {\n    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;\n    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);\n  }\n\n});\n\nif (process.env.NODE_ENV === 'development') {\n  Object.assign(dragConfigResolver, {\n    useTouch(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`useTouch\\` option has been renamed to \\`pointer.touch\\`. Use it as in \\`{ pointer: { touch: true } }\\`.`);\n      }\n\n      return NaN;\n    },\n\n    experimental_preventWindowScrollY(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`experimental_preventWindowScrollY\\` option has been renamed to \\`preventScroll\\`.`);\n      }\n\n      return NaN;\n    },\n\n    swipeVelocity(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeVelocity\\` option has been renamed to \\`swipe.velocity\\`. Use it as in \\`{ swipe: { velocity: 0.5 } }\\`.`);\n      }\n\n      return NaN;\n    },\n\n    swipeDistance(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDistance\\` option has been renamed to \\`swipe.distance\\`. Use it as in \\`{ swipe: { distance: 50 } }\\`.`);\n      }\n\n      return NaN;\n    },\n\n    swipeDuration(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDuration\\` option has been renamed to \\`swipe.duration\\`. Use it as in \\`{ swipe: { duration: 250 } }\\`.`);\n      }\n\n      return NaN;\n    }\n\n  });\n}\n\nconst SCALE_ANGLE_RATIO_INTENT_DEG = 30;\nconst PINCH_WHEEL_RATIO = 100;\nclass PinchEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'pinching');\n\n    _defineProperty(this, \"aliasKey\", 'da');\n  }\n\n  init() {\n    this.state.offset = [1, 0];\n    this.state.lastOffset = [1, 0];\n    this.state._pointerEvents = new Map();\n  }\n\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._touchIds = [];\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n    state.turns = 0;\n  }\n\n  computeOffset() {\n    const {\n      type,\n      movement,\n      lastOffset\n    } = this.state;\n\n    if (type === 'wheel') {\n      this.state.offset = V.add(movement, lastOffset);\n    } else {\n      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];\n    }\n  }\n\n  computeMovement() {\n    const {\n      offset,\n      lastOffset\n    } = this.state;\n    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];\n  }\n\n  axisIntent() {\n    const state = this.state;\n    const [_m0, _m1] = state._movement;\n\n    if (!state.axis) {\n      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);\n      if (axisMovementDifference < 0) state.axis = 'angle';else if (axisMovementDifference > 0) state.axis = 'scale';\n    }\n  }\n\n  restrictToAxis(v) {\n    if (this.config.lockDirection) {\n      if (this.state.axis === 'scale') v[1] = 0;else if (this.state.axis === 'angle') v[0] = 0;\n    }\n  }\n\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    setTimeout(() => {\n      state.canceled = true;\n      state._active = false;\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n\n  touchStart(event) {\n    this.ctrl.setEventIds(event);\n    const state = this.state;\n    const ctrlTouchIds = this.ctrl.touchIds;\n\n    if (state._active) {\n      if (state._touchIds.every(id => ctrlTouchIds.has(id))) return;\n    }\n\n    if (ctrlTouchIds.size < 2) return;\n    this.start(event);\n    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);\n    const payload = touchDistanceAngle(event, state._touchIds);\n    this.pinchStart(event, payload);\n  }\n\n  pointerStart(event) {\n    if (event.buttons != null && event.buttons % 2 !== 1) return;\n    this.ctrl.setEventIds(event);\n    event.target.setPointerCapture(event.pointerId);\n    const state = this.state;\n    const _pointerEvents = state._pointerEvents;\n    const ctrlPointerIds = this.ctrl.pointerIds;\n\n    if (state._active) {\n      if (Array.from(_pointerEvents.keys()).every(id => ctrlPointerIds.has(id))) return;\n    }\n\n    if (_pointerEvents.size < 2) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n\n    if (state._pointerEvents.size < 2) return;\n    this.start(event);\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    this.pinchStart(event, payload);\n  }\n\n  pinchStart(event, payload) {\n    const state = this.state;\n    state.origin = payload.origin;\n    this.computeValues([payload.distance, payload.angle]);\n    this.computeInitial();\n    this.compute(event);\n    this.emit();\n  }\n\n  touchMove(event) {\n    if (!this.state._active) return;\n    const payload = touchDistanceAngle(event, this.state._touchIds);\n    this.pinchMove(event, payload);\n  }\n\n  pointerMove(event) {\n    const _pointerEvents = this.state._pointerEvents;\n\n    if (_pointerEvents.has(event.pointerId)) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n\n    if (!this.state._active) return;\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    this.pinchMove(event, payload);\n  }\n\n  pinchMove(event, payload) {\n    const state = this.state;\n    const prev_a = state._values[1];\n    const delta_a = payload.angle - prev_a;\n    let delta_turns = 0;\n    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);\n    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);\n    state.origin = payload.origin;\n    state.turns = delta_turns;\n    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];\n    this.compute(event);\n    this.emit();\n  }\n\n  touchEnd(event) {\n    this.ctrl.setEventIds(event);\n    if (!this.state._active) return;\n\n    if (this.state._touchIds.some(id => !this.ctrl.touchIds.has(id))) {\n      this.state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n\n  pointerEnd(event) {\n    const state = this.state;\n    this.ctrl.setEventIds(event);\n\n    try {\n      event.target.releasePointerCapture(event.pointerId);\n    } catch (_unused) {}\n\n    if (state._pointerEvents.has(event.pointerId)) {\n      state._pointerEvents.delete(event.pointerId);\n    }\n\n    if (!state._active) return;\n\n    if (state._pointerEvents.size < 2) {\n      state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n\n  gestureStart(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    if (state._active) return;\n    this.start(event);\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n\n  gestureMove(event) {\n    if (event.cancelable) event.preventDefault();\n    if (!this.state._active) return;\n    const state = this.state;\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    const _previousMovement = state._movement;\n    state._movement = [event.scale - 1, event.rotation];\n    state._delta = V.sub(state._movement, _previousMovement);\n    this.compute(event);\n    this.emit();\n  }\n\n  gestureEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n\n  wheel(event) {\n    const modifierKey = this.config.modifierKey;\n    if (modifierKey && !event[modifierKey]) return;\n    if (!this.state._active) this.wheelStart(event);else this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n\n  wheelStart(event) {\n    this.start(event);\n    this.wheelChange(event);\n  }\n\n  wheelChange(event) {\n    const isR3f = ('uv' in event);\n\n    if (!isR3f) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n\n      if (process.env.NODE_ENV === 'development' && !event.defaultPrevented) {\n        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \\`target\\` option.\\n\\nThis message will only appear in development mode.`);\n      }\n    }\n\n    const state = this.state;\n    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];\n    V.addTo(state._movement, state._delta);\n    this.state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    const device = this.config.device;\n\n    if (!!device) {\n      bindFunction(device, 'start', this[device + 'Start'].bind(this));\n      bindFunction(device, 'change', this[device + 'Move'].bind(this));\n      bindFunction(device, 'end', this[device + 'End'].bind(this));\n      bindFunction(device, 'cancel', this[device + 'End'].bind(this));\n    } else {\n      bindFunction('wheel', '', this.wheel.bind(this), {\n        passive: false\n      });\n    }\n  }\n\n}\n\nconst pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  device(_v, _k, {\n    shared,\n    pointer: {\n      touch = false\n    } = {}\n  }) {\n    const sharedConfig = shared;\n    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return 'gesture';\n    if (SUPPORT.touch && touch) return 'touch';\n\n    if (SUPPORT.touchscreen) {\n      if (SUPPORT.pointer) return 'pointer';\n      if (SUPPORT.touch) return 'touch';\n    }\n  },\n\n  bounds(_v, _k, {\n    scaleBounds = {},\n    angleBounds = {}\n  }) {\n    const _scaleBounds = state => {\n      const D = assignDefault(call(scaleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D.min, D.max];\n    };\n\n    const _angleBounds = state => {\n      const A = assignDefault(call(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A.min, A.max];\n    };\n\n    if (typeof scaleBounds !== 'function' && typeof angleBounds !== 'function') return [_scaleBounds(), _angleBounds()];\n    return state => [_scaleBounds(state), _angleBounds(state)];\n  },\n\n  threshold(value, _k, config) {\n    this.lockDirection = config.axis === 'lock';\n    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);\n    return threshold;\n  },\n\n  modifierKey(value) {\n    if (value === undefined) return 'ctrlKey';\n    return value;\n  }\n\n});\n\nclass MoveEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'moving');\n  }\n\n  move(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    if (!this.state._active) this.moveStart(event);else this.moveChange(event);\n    this.timeoutStore.add('moveEnd', this.moveEnd.bind(this));\n  }\n\n  moveStart(event) {\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.computeInitial();\n    this.emit();\n  }\n\n  moveChange(event) {\n    if (!this.state._active) return;\n    const values = pointerValues(event);\n    const state = this.state;\n    state._delta = V.sub(values, state._values);\n    V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n\n  moveEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('pointer', 'change', this.move.bind(this));\n    bindFunction('pointer', 'leave', this.moveEnd.bind(this));\n  }\n\n}\n\nconst moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nclass ScrollEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'scrolling');\n  }\n\n  scroll(event) {\n    if (!this.state._active) this.start(event);\n    this.scrollChange(event);\n    this.timeoutStore.add('scrollEnd', this.scrollEnd.bind(this));\n  }\n\n  scrollChange(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    const values = scrollValues(event);\n    state._delta = V.sub(values, state._values);\n    V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n\n  scrollEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('scroll', '', this.scroll.bind(this));\n  }\n\n}\n\nconst scrollConfigResolver = coordinatesConfigResolver;\n\nclass WheelEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'wheeling');\n  }\n\n  wheel(event) {\n    if (!this.state._active) this.start(event);\n    this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n\n  wheelChange(event) {\n    const state = this.state;\n    state._delta = wheelValues(event);\n    V.addTo(state._movement, state._delta);\n    const [ox, oy] = state.overflow;\n    const [dx, dy] = state._delta;\n    const [dirx, diry] = state._direction;\n\n    if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {\n      state._movement[0] = state._movementBound[0];\n    }\n\n    if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {\n      state._movement[1] = state._movementBound[1];\n    }\n\n    this.compute(event);\n    this.emit();\n  }\n\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('wheel', '', this.wheel.bind(this));\n  }\n\n}\n\nconst wheelConfigResolver = coordinatesConfigResolver;\n\nclass HoverEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'hovering');\n  }\n\n  enter(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.emit();\n  }\n\n  leave(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    const state = this.state;\n    if (!state._active) return;\n    state._active = false;\n    const values = pointerValues(event);\n    state._movement = state._delta = V.sub(values, state._values);\n    this.computeValues(values);\n    this.compute(event);\n    state.delta = state.movement;\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('pointer', 'enter', this.enter.bind(this));\n    bindFunction('pointer', 'leave', this.leave.bind(this));\n  }\n\n}\n\nconst hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nconst EngineMap = new Map();\nconst ConfigResolverMap = new Map();\nfunction registerAction(action) {\n  EngineMap.set(action.key, action.engine);\n  ConfigResolverMap.set(action.key, action.resolver);\n}\nconst dragAction = {\n  key: 'drag',\n  engine: DragEngine,\n  resolver: dragConfigResolver\n};\nconst hoverAction = {\n  key: 'hover',\n  engine: HoverEngine,\n  resolver: hoverConfigResolver\n};\nconst moveAction = {\n  key: 'move',\n  engine: MoveEngine,\n  resolver: moveConfigResolver\n};\nconst pinchAction = {\n  key: 'pinch',\n  engine: PinchEngine,\n  resolver: pinchConfigResolver\n};\nconst scrollAction = {\n  key: 'scroll',\n  engine: ScrollEngine,\n  resolver: scrollConfigResolver\n};\nconst wheelAction = {\n  key: 'wheel',\n  engine: WheelEngine,\n  resolver: wheelConfigResolver\n};\n\nexport { ConfigResolverMap as C, EngineMap as E, SUPPORT as S, _objectSpread2 as _, _defineProperty as a, touchIds as b, chain as c, toHandlerProp as d, dragAction as e, pinchAction as f, hoverAction as h, isTouch as i, moveAction as m, parseProp as p, registerAction as r, scrollAction as s, toDomEventType as t, wheelAction as w };\n","function clamp(v, min, max) {\n  return Math.max(min, Math.min(v, max));\n}\nconst V = {\n  toVector(v, fallback) {\n    if (v === undefined) v = fallback;\n    return Array.isArray(v) ? v : [v, v];\n  },\n\n  add(v1, v2) {\n    return [v1[0] + v2[0], v1[1] + v2[1]];\n  },\n\n  sub(v1, v2) {\n    return [v1[0] - v2[0], v1[1] - v2[1]];\n  },\n\n  addTo(v1, v2) {\n    v1[0] += v2[0];\n    v1[1] += v2[1];\n  },\n\n  subTo(v1, v2) {\n    v1[0] -= v2[0];\n    v1[1] -= v2[1];\n  }\n\n};\n\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\n\nfunction rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {\n  if (constant === 0) return clamp(position, min, max);\n  if (position < min) return -rubberband(min - position, max - min, constant) + min;\n  if (position > max) return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\nfunction computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {\n  const [[X0, X1], [Y0, Y1]] = bounds;\n  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];\n}\n\nexport { V, computeRubberband as c, rubberbandIfOutOfBounds as r };\n","export { C as ConfigResolverMap, E as EngineMap, e as dragAction, h as hoverAction, m as moveAction, f as pinchAction, r as registerAction, s as scrollAction, w as wheelAction } from '../../dist/actions-8e12537b.esm.js';\nimport '../../dist/maths-b2a210f4.esm.js';\n","import { S as SUPPORT, C as ConfigResolverMap, _ as _objectSpread2, a as _defineProperty, t as toDomEventType, i as isTouch, b as touchIds, E as EngineMap, c as chain, p as parseProp, d as toHandlerProp } from './actions-8e12537b.esm.js';\nimport './maths-b2a210f4.esm.js';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nconst sharedConfigResolver = {\n  target(value) {\n    if (value) {\n      return () => 'current' in value ? value.current : value;\n    }\n\n    return undefined;\n  },\n\n  enabled(value = true) {\n    return value;\n  },\n\n  window(value = SUPPORT.isBrowser ? window : undefined) {\n    return value;\n  },\n\n  eventOptions({\n    passive = true,\n    capture = false\n  } = {}) {\n    return {\n      passive,\n      capture\n    };\n  },\n\n  transform(value) {\n    return value;\n  }\n\n};\n\nconst _excluded = [\"target\", \"eventOptions\", \"window\", \"enabled\", \"transform\"];\nfunction resolveWith(config = {}, resolvers) {\n  const result = {};\n\n  for (const [key, resolver] of Object.entries(resolvers)) {\n    switch (typeof resolver) {\n      case 'function':\n        if (process.env.NODE_ENV === 'development') {\n          const r = resolver.call(result, config[key], key, config);\n          if (!Number.isNaN(r)) result[key] = r;\n        } else {\n          result[key] = resolver.call(result, config[key], key, config);\n        }\n\n        break;\n\n      case 'object':\n        result[key] = resolveWith(config[key], resolver);\n        break;\n\n      case 'boolean':\n        if (resolver) result[key] = config[key];\n        break;\n    }\n  }\n\n  return result;\n}\nfunction parse(config, gestureKey) {\n  const _ref = config,\n        {\n    target,\n    eventOptions,\n    window,\n    enabled,\n    transform\n  } = _ref,\n        rest = _objectWithoutProperties(_ref, _excluded);\n\n  const _config = {\n    shared: resolveWith({\n      target,\n      eventOptions,\n      window,\n      enabled,\n      transform\n    }, sharedConfigResolver)\n  };\n\n  if (gestureKey) {\n    const resolver = ConfigResolverMap.get(gestureKey);\n    _config[gestureKey] = resolveWith(_objectSpread2({\n      shared: _config.shared\n    }, rest), resolver);\n  } else {\n    for (const key in rest) {\n      const resolver = ConfigResolverMap.get(key);\n\n      if (resolver) {\n        _config[key] = resolveWith(_objectSpread2({\n          shared: _config.shared\n        }, rest[key]), resolver);\n      } else if (process.env.NODE_ENV === 'development') {\n        if (!['drag', 'pinch', 'scroll', 'wheel', 'move', 'hover'].includes(key)) {\n          if (key === 'domTarget') {\n            throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n          }\n\n          console.warn(`[@use-gesture]: Unknown config key \\`${key}\\` was used. Please read the documentation for further information.`);\n        }\n      }\n    }\n  }\n\n  return _config;\n}\n\nclass EventStore {\n  constructor(ctrl) {\n    _defineProperty(this, \"_listeners\", []);\n\n    this._ctrl = ctrl;\n  }\n\n  add(element, device, action, handler, options) {\n    const type = toDomEventType(device, action);\n\n    const eventOptions = _objectSpread2(_objectSpread2({}, this._ctrl.config.shared.eventOptions), options);\n\n    element.addEventListener(type, handler, eventOptions);\n\n    this._listeners.push(() => element.removeEventListener(type, handler, eventOptions));\n  }\n\n  clean() {\n    this._listeners.forEach(remove => remove());\n\n    this._listeners = [];\n  }\n\n}\n\nclass TimeoutStore {\n  constructor() {\n    _defineProperty(this, \"_timeouts\", new Map());\n  }\n\n  add(key, callback, ms = 140, ...args) {\n    this.remove(key);\n\n    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));\n  }\n\n  remove(key) {\n    const timeout = this._timeouts.get(key);\n\n    if (timeout) window.clearTimeout(timeout);\n  }\n\n  clean() {\n    this._timeouts.forEach(timeout => void window.clearTimeout(timeout));\n\n    this._timeouts.clear();\n  }\n\n}\n\nclass Controller {\n  constructor(handlers) {\n    _defineProperty(this, \"gestures\", new Set());\n\n    _defineProperty(this, \"_targetEventStore\", new EventStore(this));\n\n    _defineProperty(this, \"gestureEventStores\", {});\n\n    _defineProperty(this, \"gestureTimeoutStores\", {});\n\n    _defineProperty(this, \"handlers\", {});\n\n    _defineProperty(this, \"config\", {});\n\n    _defineProperty(this, \"pointerIds\", new Set());\n\n    _defineProperty(this, \"touchIds\", new Set());\n\n    _defineProperty(this, \"state\", {\n      shared: {\n        shiftKey: false,\n        metaKey: false,\n        ctrlKey: false,\n        altKey: false\n      }\n    });\n\n    resolveGestures(this, handlers);\n  }\n\n  setEventIds(event) {\n    if (isTouch(event)) {\n      this.touchIds = new Set(touchIds(event));\n    } else if ('pointerId' in event) {\n      if (event.type === 'pointerup' || event.type === 'pointercancel') this.pointerIds.delete(event.pointerId);else if (event.type === 'pointerdown') this.pointerIds.add(event.pointerId);\n    }\n  }\n\n  applyHandlers(handlers, nativeHandlers) {\n    this.handlers = handlers;\n    this.nativeHandlers = nativeHandlers;\n  }\n\n  applyConfig(config, gestureKey) {\n    this.config = parse(config, gestureKey);\n  }\n\n  clean() {\n    this._targetEventStore.clean();\n\n    for (const key of this.gestures) {\n      this.gestureEventStores[key].clean();\n      this.gestureTimeoutStores[key].clean();\n    }\n  }\n\n  effect() {\n    if (this.config.shared.target) this.bind();\n    return () => this._targetEventStore.clean();\n  }\n\n  bind(...args) {\n    const sharedConfig = this.config.shared;\n    const eventOptions = sharedConfig.eventOptions;\n    const props = {};\n    let target;\n\n    if (sharedConfig.target) {\n      target = sharedConfig.target();\n      if (!target) return;\n    }\n\n    const bindFunction = bindToProps(props, eventOptions, !!target);\n\n    if (sharedConfig.enabled) {\n      for (const gestureKey of this.gestures) {\n        if (this.config[gestureKey].enabled) {\n          const Engine = EngineMap.get(gestureKey);\n          new Engine(this, args, gestureKey).bind(bindFunction);\n        }\n      }\n\n      for (const eventKey in this.nativeHandlers) {\n        bindFunction(eventKey, '', event => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {\n          event,\n          args\n        })), undefined, true);\n      }\n    }\n\n    for (const handlerProp in props) {\n      props[handlerProp] = chain(...props[handlerProp]);\n    }\n\n    if (!target) return props;\n\n    for (const handlerProp in props) {\n      const {\n        device,\n        capture,\n        passive\n      } = parseProp(handlerProp);\n\n      this._targetEventStore.add(target, device, '', props[handlerProp], {\n        capture,\n        passive\n      });\n    }\n  }\n\n}\n\nfunction setupGesture(ctrl, gestureKey) {\n  ctrl.gestures.add(gestureKey);\n  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl);\n  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();\n}\n\nfunction resolveGestures(ctrl, internalHandlers) {\n  if (internalHandlers.drag) setupGesture(ctrl, 'drag');\n  if (internalHandlers.wheel) setupGesture(ctrl, 'wheel');\n  if (internalHandlers.scroll) setupGesture(ctrl, 'scroll');\n  if (internalHandlers.move) setupGesture(ctrl, 'move');\n  if (internalHandlers.pinch) setupGesture(ctrl, 'pinch');\n  if (internalHandlers.hover) setupGesture(ctrl, 'hover');\n}\n\nconst bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {\n  var _options$capture, _options$passive;\n\n  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;\n  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;\n  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);\n  if (withPassiveOption && passive) handlerProp += 'Passive';\n  props[handlerProp] = props[handlerProp] || [];\n  props[handlerProp].push(handler);\n};\n\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\n\nfunction sortHandlers(_handlers) {\n  const native = {};\n  const handlers = {};\n  const actions = new Set();\n\n  for (let key in _handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handlers[key] = _handlers[key];\n    } else {\n      native[key] = _handlers[key];\n    }\n  }\n\n  return [handlers, native, actions];\n}\n\nfunction registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {\n  if (!actions.has(handlerKey)) return;\n\n  if (!EngineMap.has(key)) {\n    if (process.env.NODE_ENV === 'development') {\n      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \\`${key}\\` gesture but isn't properly configured.\\n\\nPlease add \\`${key}Action\\` when creating your handler.`);\n    }\n\n    return;\n  }\n\n  const startKey = handlerKey + 'Start';\n  const endKey = handlerKey + 'End';\n\n  const fn = state => {\n    let memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n\n  internalHandlers[key] = fn;\n  config[key] = config[key] || {};\n}\n\nfunction parseMergedHandlers(mergedHandlers, mergedConfig) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);\n  const internalHandlers = {};\n  registerGesture(actions, handlers, 'onDrag', 'drag', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onWheel', 'wheel', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onScroll', 'scroll', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onPinch', 'pinch', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onMove', 'move', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onHover', 'hover', internalHandlers, mergedConfig);\n  return {\n    handlers: internalHandlers,\n    config: mergedConfig,\n    nativeHandlers\n  };\n}\n\nexport { Controller, parseMergedHandlers };\n","export { r as rubberbandIfOutOfBounds } from '../../dist/maths-b2a210f4.esm.js';\n","\n","import { registerAction, dragAction, pinchAction, wheelAction, scrollAction, moveAction, hoverAction } from '@use-gesture/core/actions';\nexport * from '@use-gesture/core/actions';\nimport React from 'react';\nimport { Controller, parseMergedHandlers } from '@use-gesture/core';\nexport * from '@use-gesture/core/utils';\nexport * from '@use-gesture/core/types';\n\nfunction useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {\n  const ctrl = React.useMemo(() => new Controller(handlers), []);\n  ctrl.applyHandlers(handlers, nativeHandlers);\n  ctrl.applyConfig(config, gestureKey);\n  React.useEffect(ctrl.effect.bind(ctrl));\n  React.useEffect(() => {\n    return ctrl.clean.bind(ctrl);\n  }, []);\n\n  if (config.target === undefined) {\n    return ctrl.bind.bind(ctrl);\n  }\n\n  return undefined;\n}\n\nfunction useDrag(handler, config = {}) {\n  registerAction(dragAction);\n  return useRecognizers({\n    drag: handler\n  }, config, 'drag');\n}\n\nfunction usePinch(handler, config = {}) {\n  registerAction(pinchAction);\n  return useRecognizers({\n    pinch: handler\n  }, config, 'pinch');\n}\n\nfunction useWheel(handler, config = {}) {\n  registerAction(wheelAction);\n  return useRecognizers({\n    wheel: handler\n  }, config, 'wheel');\n}\n\nfunction useScroll(handler, config = {}) {\n  registerAction(scrollAction);\n  return useRecognizers({\n    scroll: handler\n  }, config, 'scroll');\n}\n\nfunction useMove(handler, config = {}) {\n  registerAction(moveAction);\n  return useRecognizers({\n    move: handler\n  }, config, 'move');\n}\n\nfunction useHover(handler, config = {}) {\n  registerAction(hoverAction);\n  return useRecognizers({\n    hover: handler\n  }, config, 'hover');\n}\n\nfunction createUseGesture(actions) {\n  actions.forEach(registerAction);\n  return function useGesture(_handlers, _config = {}) {\n    const {\n      handlers,\n      nativeHandlers,\n      config\n    } = parseMergedHandlers(_handlers, _config);\n    return useRecognizers(handlers, config, undefined, nativeHandlers);\n  };\n}\n\nfunction useGesture(handlers, config = {}) {\n  const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);\n  return hook(handlers, config);\n}\n\nexport { createUseGesture, useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };\n","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","export {};\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport Papa from 'papaparse';\nexport const PREVIEW_ROW_COUNT = 5;\n// polyfill as implemented in https://github.com/eligrey/Blob.js/blob/master/Blob.js#L653\n// (this is for Safari pre v14.1)\nfunction streamForBlob(blob) {\n    if (blob.stream) {\n        return blob.stream();\n    }\n    const res = new Response(blob);\n    if (res.body) {\n        return res.body;\n    }\n    throw new Error('This browser does not support client-side file reads');\n}\n// incredibly cheap wrapper exposing a subset of stream.Readable interface just for PapaParse usage\n// @todo chunk size\nfunction nodeStreamWrapper(stream, encoding) {\n    let dataHandler = null;\n    let endHandler = null;\n    let errorHandler = null;\n    let isStopped = false;\n    let pausePromise = null;\n    let pauseResolver = null;\n    function runReaderPump() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // ensure this is truly in the next tick after uncorking\n            yield Promise.resolve();\n            const streamReader = stream.getReader();\n            const decoder = new TextDecoder(encoding); // this also strips BOM by default\n            try {\n                // main reader pump loop\n                while (!isStopped) {\n                    // perform read from upstream\n                    const { done, value } = yield streamReader.read();\n                    // wait if we became paused since last data event\n                    if (pausePromise) {\n                        yield pausePromise;\n                    }\n                    // check again if stopped and unlistened\n                    if (isStopped || !dataHandler || !endHandler) {\n                        return;\n                    }\n                    // final data flush and end notification\n                    if (done) {\n                        const lastChunkString = decoder.decode(value); // value is empty but pass just in case\n                        if (lastChunkString) {\n                            dataHandler(lastChunkString);\n                        }\n                        endHandler(undefined);\n                        return;\n                    }\n                    // otherwise, normal data event after stream-safe decoding\n                    const chunkString = decoder.decode(value, { stream: true });\n                    dataHandler(chunkString);\n                }\n            }\n            finally {\n                // always release the lock\n                streamReader.releaseLock();\n            }\n        });\n    }\n    const self = {\n        // marker properties to make PapaParse think this is a Readable object\n        readable: true,\n        read() {\n            throw new Error('only flowing mode is emulated');\n        },\n        on(event, callback) {\n            switch (event) {\n                case 'data':\n                    if (dataHandler) {\n                        throw new Error('two data handlers not supported');\n                    }\n                    dataHandler = callback;\n                    // flowing state started, run the main pump loop\n                    runReaderPump().catch((error) => {\n                        if (errorHandler) {\n                            errorHandler(error);\n                        }\n                        else {\n                            // rethrow to show error in console\n                            throw error;\n                        }\n                    });\n                    return;\n                case 'end':\n                    if (endHandler) {\n                        throw new Error('two end handlers not supported');\n                    }\n                    endHandler = callback;\n                    return;\n                case 'error':\n                    if (errorHandler) {\n                        throw new Error('two error handlers not supported');\n                    }\n                    errorHandler = callback;\n                    return;\n            }\n            throw new Error('unknown stream shim event: ' + event);\n        },\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        removeListener(event, callback) {\n            // stop and clear everything for simplicity\n            isStopped = true;\n            dataHandler = null;\n            endHandler = null;\n            errorHandler = null;\n        },\n        pause() {\n            if (!pausePromise) {\n                pausePromise = new Promise((resolve) => {\n                    pauseResolver = resolve;\n                });\n            }\n            return self;\n        },\n        resume() {\n            if (pauseResolver) {\n                pauseResolver(); // waiting code will proceed in next tick\n                pausePromise = null;\n                pauseResolver = null;\n            }\n            return self;\n        }\n    };\n    // pass ourselves off as a real Node stream\n    return self;\n}\nexport function parsePreview(file, customConfig) {\n    // wrap synchronous errors in promise\n    return new Promise((resolve) => {\n        let firstChunk = null;\n        let firstWarning = undefined;\n        const rowAccumulator = [];\n        function reportSuccess() {\n            // PapaParse normally complains first anyway, but might as well flag it\n            if (rowAccumulator.length === 0) {\n                return {\n                    parseError: new Error('File is empty'),\n                    file\n                };\n            }\n            // remember whether this file has only one line\n            const isSingleLine = rowAccumulator.length === 1;\n            // fill preview with blanks if needed\n            while (rowAccumulator.length < PREVIEW_ROW_COUNT) {\n                rowAccumulator.push([]);\n            }\n            resolve({\n                file,\n                parseError: undefined,\n                parseWarning: firstWarning || undefined,\n                firstChunk: firstChunk || '',\n                firstRows: rowAccumulator,\n                isSingleLine\n            });\n        }\n        // use our own multibyte-safe streamer, bail after first chunk\n        // (this used to add skipEmptyLines but that was hiding possible parse errors)\n        // @todo wait for upstream multibyte fix in PapaParse: https://github.com/mholt/PapaParse/issues/908\n        const nodeStream = nodeStreamWrapper(streamForBlob(file), customConfig.encoding || 'utf-8');\n        Papa.parse(nodeStream, Object.assign(Object.assign({}, customConfig), { chunkSize: 10000, preview: PREVIEW_ROW_COUNT, error: (error) => {\n                resolve({\n                    parseError: error,\n                    file\n                });\n            }, beforeFirstChunk: (chunk) => {\n                firstChunk = chunk;\n            }, chunk: ({ data, errors }, parser) => {\n                data.forEach((row) => {\n                    const stringRow = row.map((item) => typeof item === 'string' ? item : '');\n                    rowAccumulator.push(stringRow);\n                });\n                if (errors.length > 0 && !firstWarning) {\n                    firstWarning = errors[0];\n                }\n                // finish parsing once we got enough data, otherwise try for more\n                // (in some cases PapaParse flushes out last line as separate chunk)\n                if (rowAccumulator.length >= PREVIEW_ROW_COUNT) {\n                    nodeStream.pause(); // parser does not pause source stream, do it here explicitly\n                    parser.abort();\n                    reportSuccess();\n                }\n            }, complete: reportSuccess }));\n    }).catch((error) => {\n        return {\n            parseError: error,\n            file\n        };\n    });\n}\nexport function processFile(input, reportProgress, callback) {\n    const { file, hasHeaders, papaParseConfig, fieldAssignments } = input;\n    const fieldNames = Object.keys(fieldAssignments);\n    // wrap synchronous errors in promise\n    return new Promise((resolve, reject) => {\n        // skip first line if needed\n        let skipLine = hasHeaders;\n        let processedCount = 0;\n        // use our own multibyte-safe decoding streamer\n        // @todo wait for upstream multibyte fix in PapaParse: https://github.com/mholt/PapaParse/issues/908\n        const nodeStream = nodeStreamWrapper(streamForBlob(file), papaParseConfig.encoding || 'utf-8');\n        Papa.parse(nodeStream, Object.assign(Object.assign({}, papaParseConfig), { chunkSize: papaParseConfig.chunkSize || 10000, error: (error) => {\n                reject(error);\n            }, chunk: ({ data }, parser) => {\n                // pause to wait until the rows are consumed\n                nodeStream.pause(); // parser does not pause source stream, do it here explicitly\n                parser.pause();\n                const skipped = skipLine && data.length > 0;\n                const rows = (skipped ? data.slice(1) : data).map((row) => {\n                    const stringRow = row.map((item) => typeof item === 'string' ? item : '');\n                    const record = {};\n                    fieldNames.forEach((fieldName) => {\n                        const columnIndex = fieldAssignments[fieldName];\n                        if (columnIndex !== undefined) {\n                            record[fieldName] = stringRow[columnIndex];\n                        }\n                    });\n                    return record; // @todo look into a more precise setup\n                });\n                // clear line skip flag if there was anything to skip\n                if (skipped) {\n                    skipLine = false;\n                }\n                // info snapshot for processing callback\n                const info = {\n                    startIndex: processedCount\n                };\n                processedCount += rows.length;\n                // @todo collect errors\n                reportProgress(rows.length);\n                // wrap sync errors in promise\n                // (avoid invoking callback if there are no rows to consume)\n                const whenConsumed = new Promise((resolve) => {\n                    const result = rows.length ? callback(rows, info) : undefined;\n                    // introduce delay to allow a frame render\n                    setTimeout(() => resolve(result), 0);\n                });\n                // unpause parsing when done\n                whenConsumed.then(() => {\n                    nodeStream.resume();\n                    parser.resume();\n                }, () => {\n                    // @todo collect errors\n                    nodeStream.resume();\n                    parser.resume();\n                });\n            }, complete: () => {\n                resolve();\n            } }));\n    });\n}\n","import React from 'react';\nimport './TextButton.scss';\nexport const TextButton = ({ disabled, onClick, children }) => {\n    return (React.createElement(\"button\", { className: \"CSVImporter_TextButton\", type: \"button\" // avoid triggering form submit\n        , disabled: disabled, onClick: onClick }, children));\n};\n","import React from 'react';\nimport './IconButton.scss';\nexport const IconButton = ({ type, label, small, focusOnly, disabled, onClick }) => {\n    return (React.createElement(\"button\", { className: \"CSVImporter_IconButton\", type: \"button\" // avoid triggering form submit\n        , \"aria-label\": label, disabled: disabled, onClick: onClick, \"data-small\": !!small, \"data-focus-only\": !!focusOnly },\n        React.createElement(\"span\", { \"data-type\": type })));\n};\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types -- all exports are ImporterLocale which is already fully typed */\nexport const enUS = {\n    general: {\n        goToPreviousStepTooltip: 'Go to previous step'\n    },\n    fileStep: {\n        initialDragDropPrompt: 'Drag-and-drop CSV file here, or click to select in folder',\n        activeDragDropPrompt: 'Drop CSV file here...',\n        getImportError: (message) => `Import error: ${message}`,\n        getDataFormatError: (message) => `Please check data formatting: ${message}`,\n        goBackButton: 'Go Back',\n        nextButton: 'Choose columns',\n        rawFileContentsHeading: 'Raw File Contents',\n        previewImportHeading: 'Preview Import',\n        dataHasHeadersCheckbox: 'Data has headers',\n        previewLoadingStatus: 'Loading preview...'\n    },\n    fieldsStep: {\n        stepSubtitle: 'Select Columns',\n        requiredFieldsError: 'Please assign all required fields',\n        nextButton: 'Import',\n        dragSourceAreaCaption: 'Columns to import',\n        getDragSourcePageIndicator: (currentPage, pageCount) => `Page ${currentPage} of ${pageCount}`,\n        getDragSourceActiveStatus: (columnCode) => `Assigning column ${columnCode}`,\n        nextColumnsTooltip: 'Show next columns',\n        previousColumnsTooltip: 'Show previous columns',\n        clearAssignmentTooltip: 'Clear column assignment',\n        selectColumnTooltip: 'Select column for assignment',\n        unselectColumnTooltip: 'Unselect column',\n        dragTargetAreaCaption: 'Target fields',\n        getDragTargetOptionalCaption: (field) => `${field} (optional)`,\n        getDragTargetRequiredCaption: (field) => `${field} (required)`,\n        dragTargetPlaceholder: 'Drag column here',\n        getDragTargetAssignTooltip: (columnCode) => `Assign column ${columnCode}`,\n        dragTargetClearTooltip: 'Clear column assignment',\n        columnCardDummyHeader: 'Unassigned field',\n        getColumnCardHeader: (code) => `Column ${code}`\n    },\n    progressStep: {\n        stepSubtitle: 'Import',\n        uploadMoreButton: 'Upload More',\n        finishButton: 'Finish',\n        statusError: 'Could not import',\n        statusComplete: 'Complete',\n        statusPending: 'Importing...',\n        processedRowsLabel: 'Processed rows:'\n    }\n};\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types -- all exports are ImporterLocale which is already fully typed */\nexport const deDE = {\n    general: {\n        goToPreviousStepTooltip: 'Zum vorherigen Schritt'\n    },\n    fileStep: {\n        initialDragDropPrompt: 'CSV-Datei auf dieses Feld ziehen, oder klicken um eine Datei auszuwhlen',\n        activeDragDropPrompt: 'CSV-Datei auf dieses Feld ziehen...',\n        nextButton: 'Spalten auswhlen',\n        getImportError: (message) => `Fehler beim Import: ${message}`,\n        getDataFormatError: (message) => `Bitte Datenformat berprfen: ${message}`,\n        goBackButton: 'Zurck',\n        rawFileContentsHeading: 'Originaler Datei-Inhalt',\n        previewImportHeading: 'Import-Vorschau',\n        dataHasHeadersCheckbox: 'Mit Kopfzeile',\n        previewLoadingStatus: 'Vorschau wird geladen...'\n    },\n    fieldsStep: {\n        stepSubtitle: 'Spalten auswhlen',\n        requiredFieldsError: 'Bitte weise allen nicht optionalen Spalten einen Wert zu',\n        nextButton: 'Importieren',\n        dragSourceAreaCaption: 'Zu importierende Spalte',\n        getDragSourcePageIndicator: (currentPage, pageCount) => `Seite ${currentPage} von ${pageCount}`,\n        getDragSourceActiveStatus: (columnCode) => `Spalte ${columnCode} zuweisen`,\n        nextColumnsTooltip: 'Nchste Spalten anzeigen',\n        previousColumnsTooltip: 'Vorherige Spalten anzeigen',\n        clearAssignmentTooltip: 'Zugewiesene Spalte entfernen',\n        selectColumnTooltip: 'Spalte zum Zuweisen auswhlen',\n        unselectColumnTooltip: 'Spalte abwhlen',\n        dragTargetAreaCaption: 'Zielfelder',\n        getDragTargetOptionalCaption: (field) => `${field} (optional)`,\n        getDragTargetRequiredCaption: (field) => `${field} (erforderlich)`,\n        dragTargetPlaceholder: 'Spalte hierher ziehen',\n        getDragTargetAssignTooltip: (columnCode) => `Spalte ${columnCode} zuweisen`,\n        dragTargetClearTooltip: 'Zugewiesene Spalte entfernen',\n        columnCardDummyHeader: 'Nicht zugewiesenes Feld',\n        getColumnCardHeader: (code) => `Spalte ${code}`\n    },\n    progressStep: {\n        stepSubtitle: 'Importieren',\n        uploadMoreButton: 'Weitere hochladen',\n        finishButton: 'Abschlieen',\n        statusError: 'Konnte nicht importiert werden',\n        statusComplete: 'Fertig',\n        statusPending: 'Wird importiert...',\n        processedRowsLabel: 'Verarbeitete Zeilen:'\n    }\n};\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types -- all exports are ImporterLocale which is already fully typed */\nexport const itIT = {\n    general: {\n        goToPreviousStepTooltip: 'Torna indietro'\n    },\n    fileStep: {\n        initialDragDropPrompt: 'Trascina qui il file CSV, o clicca per selezionarlo dal PC',\n        activeDragDropPrompt: 'Rilascia qui il file CSV...',\n        getImportError: (message) => `Errore durante l'importazione: ${message}`,\n        getDataFormatError: (message) => `Si prega di controllare il formato dei dati: ${message}`,\n        goBackButton: 'Torna indietro',\n        nextButton: 'Seleziona le colonne',\n        rawFileContentsHeading: 'Contenuto delfile caricato',\n        previewImportHeading: 'Anteprima dei dati',\n        dataHasHeadersCheckbox: 'Intestazione presente nel file',\n        previewLoadingStatus: 'Caricamento anteprima...'\n    },\n    fieldsStep: {\n        stepSubtitle: 'Seleziona le colonne',\n        requiredFieldsError: 'Si prega di assegnare tutte le colonne richieste',\n        nextButton: 'Importa',\n        dragSourceAreaCaption: 'Colonne da importare',\n        getDragSourcePageIndicator: (currentPage, pageCount) => `Pagina ${currentPage} di ${pageCount}`,\n        getDragSourceActiveStatus: (columnCode) => `Assegnamento alla colonna ${columnCode}`,\n        nextColumnsTooltip: 'Mostra colonna successiva',\n        previousColumnsTooltip: 'Mostra colonna precedente',\n        clearAssignmentTooltip: 'Cancella tutti gli assegnamenti delle colonne',\n        selectColumnTooltip: 'Seleziona una colonna da assegnare',\n        unselectColumnTooltip: 'Deseleziona colonna',\n        dragTargetAreaCaption: 'Campi richiesti',\n        getDragTargetOptionalCaption: (field) => `${field} (opzionale)`,\n        getDragTargetRequiredCaption: (field) => `${field} (obbligatorio)`,\n        dragTargetPlaceholder: 'Trascina qui la colonna',\n        getDragTargetAssignTooltip: (columnCode) => `Assegnamento alla colonna ${columnCode}`,\n        dragTargetClearTooltip: 'Cancella gli assegnamenti alla colonna',\n        columnCardDummyHeader: 'Campo non assegnato',\n        getColumnCardHeader: (code) => `Column ${code}`\n    },\n    progressStep: {\n        stepSubtitle: 'Importa',\n        uploadMoreButton: 'Carica altri dati',\n        finishButton: 'Fine',\n        statusError: 'Errore di caricamento',\n        statusComplete: 'Completato',\n        statusPending: 'Caricamento...',\n        processedRowsLabel: 'Righe processate:'\n    }\n};\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types -- all exports are ImporterLocale which is already fully typed */\nexport const ptBR = {\n    general: {\n        goToPreviousStepTooltip: 'Voltar a etapa anterior'\n    },\n    fileStep: {\n        initialDragDropPrompt: 'Arraste e solte o arquivo CSV aqui ou clique para selecionar na pasta',\n        activeDragDropPrompt: 'Arraste e solte o arquivo CSV aqui...',\n        getImportError: (message) => `Erro ao importar: ${message}`,\n        getDataFormatError: (message) => `Por favor confira a formatao dos dados: ${message}`,\n        goBackButton: 'Voltar',\n        nextButton: 'Escolher Colunas',\n        rawFileContentsHeading: 'Contedo Bruto do Arquivo',\n        previewImportHeading: 'Visualizar Importao',\n        dataHasHeadersCheckbox: 'Os dados tm cabealhos',\n        previewLoadingStatus: 'Carregando visualizao...'\n    },\n    fieldsStep: {\n        stepSubtitle: 'Selecionar Colunas',\n        requiredFieldsError: 'Atribua todos os campos obrigatrios',\n        nextButton: 'Importar',\n        dragSourceAreaCaption: 'Colunas para importar',\n        getDragSourcePageIndicator: (currentPage, pageCount) => `Pgina ${currentPage} de ${pageCount}`,\n        getDragSourceActiveStatus: (columnCode) => `Atribuindo coluna ${columnCode}`,\n        nextColumnsTooltip: 'Mostrar as prximas colunas',\n        previousColumnsTooltip: 'Mostrar colunas anteriores',\n        clearAssignmentTooltip: 'Limpar atribuio de coluna',\n        selectColumnTooltip: 'Selecione a coluna para atribuio',\n        unselectColumnTooltip: 'Desmarcar coluna',\n        dragTargetAreaCaption: 'Campos de destino',\n        getDragTargetOptionalCaption: (field) => `${field} (opcional)`,\n        getDragTargetRequiredCaption: (field) => `${field} (obrigatrio)`,\n        dragTargetPlaceholder: 'Arraste a coluna aqui',\n        getDragTargetAssignTooltip: (columnCode) => `Atribuir coluna ${columnCode}`,\n        dragTargetClearTooltip: 'Limpar atribuio de coluna',\n        columnCardDummyHeader: 'Campo no atribudo',\n        getColumnCardHeader: (code) => `Coluna ${code}`\n    },\n    progressStep: {\n        stepSubtitle: 'Importar',\n        uploadMoreButton: 'Carregar mais',\n        finishButton: 'Finalizar',\n        statusError: 'No foi possvel importar',\n        statusComplete: 'Completo',\n        statusPending: 'Importando...',\n        processedRowsLabel: 'Linhas processadas:'\n    }\n};\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types -- all exports are ImporterLocale which is already fully typed */\nexport const daDK = {\n    general: {\n        goToPreviousStepTooltip: 'G til forrige trin'\n    },\n    fileStep: {\n        initialDragDropPrompt: 'Trk og slip CSV-fil her eller klik for at vlge fra en mappe',\n        activeDragDropPrompt: 'Slip CSV-fil her...',\n        getImportError: (message) => `Import-fejl: ${message}`,\n        getDataFormatError: (message) => `Kontrollr venligst data-formatering: ${message}`,\n        goBackButton: 'G tilbage',\n        nextButton: 'Vlg kolonner',\n        rawFileContentsHeading: 'R filindhold',\n        previewImportHeading: 'Forhndsvis Import',\n        dataHasHeadersCheckbox: 'Data sidehoved',\n        previewLoadingStatus: 'Indlser forhndsvisning...'\n    },\n    fieldsStep: {\n        stepSubtitle: 'Vlg kolonner',\n        requiredFieldsError: 'Tildel venligst alle pkrvede felter',\n        nextButton: 'Importr',\n        dragSourceAreaCaption: 'Kolonner til import',\n        getDragSourcePageIndicator: (currentPage, pageCount) => `Side ${currentPage} af ${pageCount}`,\n        getDragSourceActiveStatus: (columnCode) => `Tildeler kolonne ${columnCode}`,\n        nextColumnsTooltip: 'Vis nste kolonner',\n        previousColumnsTooltip: 'Vis forrige kolonner',\n        clearAssignmentTooltip: 'Ryd kolonne-tildeling',\n        selectColumnTooltip: 'Vlg kolonne til tildeling',\n        unselectColumnTooltip: 'Fravlg kolonne',\n        dragTargetAreaCaption: 'Ml-felter',\n        getDragTargetOptionalCaption: (field) => `${field} (valgfri)`,\n        getDragTargetRequiredCaption: (field) => `${field} (pkrvet)`,\n        dragTargetPlaceholder: 'Trk kolonne hertil',\n        getDragTargetAssignTooltip: (columnCode) => `Tildel kolonne ${columnCode}`,\n        dragTargetClearTooltip: 'Ryd kolonne-tildeling',\n        columnCardDummyHeader: 'Disponibelt felt',\n        getColumnCardHeader: (code) => `Column ${code}`\n    },\n    progressStep: {\n        stepSubtitle: 'Importr',\n        uploadMoreButton: 'Upload Mere',\n        finishButton: 'Frdiggr',\n        statusError: 'Kunne ikke importere',\n        statusComplete: 'Frdig',\n        statusPending: 'Importerer...',\n        processedRowsLabel: 'Processerede rkker:'\n    }\n};\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types -- all exports are ImporterLocale which is already fully typed */\nexport const trTR = {\n    general: {\n        goToPreviousStepTooltip: 'Bir nceki adma geri dn'\n    },\n    fileStep: {\n        initialDragDropPrompt: 'CSV dosyasn srkleyin veya kutunun iine tklayp dosyay sein',\n        activeDragDropPrompt: 'CSV dosyasn buraya brakn...',\n        getImportError: (message) => `Import hatas: ${message}`,\n        getDataFormatError: (message) => `Ltfen veri formatn kontrol edin: ${message}`,\n        goBackButton: 'Geri',\n        nextButton: 'Kolonlar Se',\n        rawFileContentsHeading: 'CSV dosyas ierii',\n        previewImportHeading: 'Import nizleme',\n        dataHasHeadersCheckbox: 'Veride balklar var',\n        previewLoadingStatus: 'nizleme ykleniyor...'\n    },\n    fieldsStep: {\n        stepSubtitle: 'Kolonlar sein',\n        requiredFieldsError: 'Ltfen zorunlu tm alanlar doldurun.',\n        nextButton: 'Import',\n        dragSourceAreaCaption: 'Import edilecek kolonlar',\n        getDragSourcePageIndicator: (currentPage, pageCount) => `${pageCount} sayfadan ${currentPage}. sayfadasnz`,\n        getDragSourceActiveStatus: (columnCode) => `${columnCode}. kolon atanyor`,\n        nextColumnsTooltip: 'Sradaki kolonlar gster',\n        previousColumnsTooltip: 'nceki kolonlar gster',\n        clearAssignmentTooltip: 'Kolon atamay temizle',\n        selectColumnTooltip: 'Atamak iin kolon seiniz',\n        unselectColumnTooltip: 'Kolonu semeyi brak',\n        dragTargetAreaCaption: 'Hedef alanlar',\n        getDragTargetOptionalCaption: (field) => `${field} (opsiyonel)`,\n        getDragTargetRequiredCaption: (field) => `${field} (zorunlu)`,\n        dragTargetPlaceholder: 'Kolonu buraya srkle',\n        getDragTargetAssignTooltip: (columnCode) => `${columnCode}. kolonu ata`,\n        dragTargetClearTooltip: 'Kolon atamay temizle',\n        columnCardDummyHeader: 'Atanmam alan',\n        getColumnCardHeader: (code) => `Kolon ${code}`\n    },\n    progressStep: {\n        stepSubtitle: 'Import',\n        uploadMoreButton: 'Sonrakileri ykle',\n        finishButton: 'Bitir',\n        statusError: 'Import edilemedi',\n        statusComplete: 'Tamamland',\n        statusPending: 'Import ediliyor...',\n        processedRowsLabel: 'lenen satr says:'\n    }\n};\n","export { enUS } from './locale_enUS';\nexport { deDE } from './locale_deDE';\nexport { itIT } from './locale_itIT';\nexport { ptBR } from './locale_ptBR';\nexport { daDK } from './locale_daDK';\nexport { trTR } from './locale_trTR';\n","import React from 'react';\nimport { enUS } from '.';\nimport { useContext } from 'react';\nexport const LocaleContext = React.createContext(enUS);\nexport function useLocale(namespace) {\n    const locale = useContext(LocaleContext);\n    return locale[namespace]; // not using memo for basic property getter\n}\n","import React, { useRef, useEffect } from 'react';\nimport { TextButton } from './TextButton';\nimport { IconButton } from './IconButton';\nimport './ImporterFrame.scss';\nimport { useLocale } from '../locale/LocaleContext';\nexport const ImporterFrame = ({ fileName, subtitle, secondaryDisabled, secondaryLabel, nextDisabled, nextLabel, error, onSecondary, onNext, onCancel, children }) => {\n    const titleRef = useRef(null);\n    const subtitleRef = useRef(null);\n    useEffect(() => {\n        if (subtitleRef.current) {\n            subtitleRef.current.focus();\n        }\n        else if (titleRef.current) {\n            titleRef.current.focus();\n        }\n    }, []);\n    const l10n = useLocale('general');\n    return (React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame\" },\n        React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__header\" },\n            React.createElement(IconButton, { label: l10n.goToPreviousStepTooltip, type: \"arrowBack\", disabled: !onCancel, onClick: onCancel }),\n            React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__headerTitle\", tabIndex: -1, ref: titleRef }, fileName),\n            subtitle ? (React.createElement(React.Fragment, null,\n                React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__headerCrumbSeparator\" },\n                    React.createElement(\"span\", null)),\n                React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__headerSubtitle\", tabIndex: -1, ref: subtitleRef }, subtitle))) : null),\n        children,\n        React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footer\" },\n            React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footerFill\" }),\n            error ? (React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footerError\", role: \"status\" }, error)) : null,\n            secondaryLabel ? (React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footerSecondary\" },\n                React.createElement(TextButton, { disabled: !!secondaryDisabled, onClick: onSecondary }, secondaryLabel))) : null,\n            nextLabel !== false ? (React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footerNext\" },\n                React.createElement(TextButton, { disabled: !!nextDisabled, onClick: onNext }, nextLabel))) : null)));\n};\n","import React, { useCallback, useRef } from 'react';\nimport { useDropzone } from 'react-dropzone';\nimport { useLocale } from '../../locale/LocaleContext';\nimport './FileSelector.scss';\nexport const FileSelector = ({ onSelected }) => {\n    const onSelectedRef = useRef(onSelected);\n    onSelectedRef.current = onSelected;\n    const dropHandler = useCallback((acceptedFiles) => {\n        // silently ignore if nothing to do\n        if (acceptedFiles.length < 1) {\n            return;\n        }\n        const file = acceptedFiles[0];\n        onSelectedRef.current(file);\n    }, []);\n    const { getRootProps, getInputProps, isDragActive } = useDropzone({\n        onDrop: dropHandler\n    });\n    const l10n = useLocale('fileStep');\n    return (React.createElement(\"div\", Object.assign({ className: \"CSVImporter_FileSelector\", \"data-active\": !!isDragActive }, getRootProps()),\n        React.createElement(\"input\", Object.assign({}, getInputProps())),\n        isDragActive ? (React.createElement(\"span\", null, l10n.activeDragDropPrompt)) : (React.createElement(\"span\", null, l10n.initialDragDropPrompt))));\n};\n","import React from 'react';\nimport { TextButton } from '../TextButton';\nimport './FormatErrorMessage.scss';\nimport { useLocale } from '../../locale/LocaleContext';\nexport const FormatErrorMessage = React.memo(({ onCancelClick, children }) => {\n    const l10n = useLocale('fileStep');\n    return (React.createElement(\"div\", { className: \"CSVImporter_FormatErrorMessage\" },\n        React.createElement(\"span\", null, children),\n        React.createElement(TextButton, { onClick: onCancelClick }, l10n.goBackButton)));\n});\n","import React from 'react';\nimport { useLocale } from '../../locale/LocaleContext';\nimport { FormatErrorMessage } from './FormatErrorMessage';\nimport './FormatRawPreview.scss';\nconst RAW_PREVIEW_SIZE = 500;\nexport const FormatRawPreview = React.memo(({ chunk, warning, onCancelClick }) => {\n    const chunkSlice = chunk.slice(0, RAW_PREVIEW_SIZE);\n    const chunkHasMore = chunk.length > RAW_PREVIEW_SIZE;\n    const l10n = useLocale('fileStep');\n    return (React.createElement(\"div\", { className: \"CSVImporter_FormatRawPreview\" },\n        React.createElement(\"div\", { className: \"CSVImporter_FormatRawPreview__scroll\" },\n            React.createElement(\"pre\", { className: \"CSVImporter_FormatRawPreview__pre\" },\n                chunkSlice,\n                chunkHasMore && React.createElement(\"aside\", null, \"...\"))),\n        warning ? (React.createElement(FormatErrorMessage, { onCancelClick: onCancelClick }, l10n.getDataFormatError(warning.message || String(warning)))) : null));\n});\n","import React from 'react';\nimport './FormatDataRowPreview.scss';\nexport const FormatDataRowPreview = React.memo(({ hasHeaders, rows }) => {\n    const headerRow = hasHeaders ? rows[0] : null;\n    const bodyRows = hasHeaders ? rows.slice(1) : rows;\n    return (React.createElement(\"div\", { className: \"CSVImporter_FormatDataRowPreview\" },\n        React.createElement(\"table\", { className: \"CSVImporter_FormatDataRowPreview__table\" },\n            headerRow && (React.createElement(\"thead\", null,\n                React.createElement(\"tr\", null, headerRow.map((item, itemIndex) => (React.createElement(\"th\", { key: itemIndex }, item)))))),\n            React.createElement(\"tbody\", null, bodyRows.map((row, rowIndex) => (React.createElement(\"tr\", { key: rowIndex }, row.map((item, itemIndex) => (React.createElement(\"td\", { key: itemIndex }, item))))))))));\n});\n","import React, { useMemo, useRef, useEffect, useState } from 'react';\nimport { parsePreview } from '../../parser';\nimport { ImporterFrame } from '../ImporterFrame';\nimport { FileSelector } from './FileSelector';\nimport { FormatRawPreview } from './FormatRawPreview';\nimport { FormatDataRowPreview } from './FormatDataRowPreview';\nimport { FormatErrorMessage } from './FormatErrorMessage';\nimport './FileStep.scss';\nimport { useLocale } from '../../locale/LocaleContext';\nexport const FileStep = ({ customConfig, defaultNoHeader, prevState, onChange, onAccept }) => {\n    const l10n = useLocale('fileStep');\n    // seed from previous state as needed\n    const [selectedFile, setSelectedFile] = useState(prevState ? prevState.file : null);\n    const [preview, setPreview] = useState(() => prevState && Object.assign({ parseError: undefined }, prevState));\n    const [papaParseConfig, setPapaParseConfig] = useState(prevState ? prevState.papaParseConfig : customConfig);\n    const [hasHeaders, setHasHeaders] = useState(prevState ? prevState.hasHeaders : false);\n    // wrap in ref to avoid triggering effect\n    const customConfigRef = useRef(customConfig);\n    customConfigRef.current = customConfig;\n    const defaultNoHeaderRef = useRef(defaultNoHeader);\n    defaultNoHeaderRef.current = defaultNoHeader;\n    const onChangeRef = useRef(onChange);\n    onChangeRef.current = onChange;\n    // notify of current state\n    useEffect(() => {\n        onChangeRef.current(preview && !preview.parseError\n            ? Object.assign(Object.assign({}, preview), { papaParseConfig, hasHeaders }) : null);\n    }, [preview, papaParseConfig, hasHeaders]);\n    // perform async preview parse once for the given file\n    const asyncLockRef = useRef(0);\n    useEffect(() => {\n        // clear other state when file selector is reset\n        if (!selectedFile) {\n            setPreview(null);\n            return;\n        }\n        // preserve existing state when parsing for this file is already complete\n        if (preview && preview.file === selectedFile) {\n            return;\n        }\n        const oplock = asyncLockRef.current;\n        // lock in the current PapaParse config instance for use in multiple spots\n        const config = customConfigRef.current;\n        // kick off the preview parse\n        parsePreview(selectedFile, config).then((results) => {\n            // ignore if stale\n            if (oplock !== asyncLockRef.current) {\n                return;\n            }\n            // save the results and the original config\n            setPreview(results);\n            setPapaParseConfig(config);\n            // pre-fill headers flag (only possible with >1 lines)\n            setHasHeaders(results.parseError\n                ? false\n                : !defaultNoHeaderRef.current && !results.isSingleLine);\n        });\n        return () => {\n            // invalidate current oplock on change or unmount\n            asyncLockRef.current += 1;\n        };\n    }, [selectedFile, preview]);\n    // clear selected file\n    // preview result content to display\n    const reportBlock = useMemo(() => {\n        if (!preview) {\n            return null;\n        }\n        if (preview.parseError) {\n            return (React.createElement(\"div\", { className: \"CSVImporter_FileStep__mainResultBlock\" },\n                React.createElement(FormatErrorMessage, { onCancelClick: () => setSelectedFile(null) }, l10n.getImportError(preview.parseError.message || String(preview.parseError)))));\n        }\n        return (React.createElement(\"div\", { className: \"CSVImporter_FileStep__mainResultBlock\" },\n            React.createElement(\"div\", { className: \"CSVImporter_FileStep__header\" }, l10n.rawFileContentsHeading),\n            React.createElement(FormatRawPreview, { chunk: preview.firstChunk, warning: preview.parseWarning, onCancelClick: () => setSelectedFile(null) }),\n            preview.parseWarning ? null : (React.createElement(React.Fragment, null,\n                React.createElement(\"div\", { className: \"CSVImporter_FileStep__header\" },\n                    l10n.previewImportHeading,\n                    !preview.isSingleLine && ( // hide setting if only one line anyway\n                    React.createElement(\"label\", { className: \"CSVImporter_FileStep__headerToggle\" },\n                        React.createElement(\"input\", { type: \"checkbox\", checked: hasHeaders, onChange: () => {\n                                setHasHeaders((prev) => !prev);\n                            } }),\n                        React.createElement(\"span\", null, l10n.dataHasHeadersCheckbox)))),\n                React.createElement(FormatDataRowPreview, { hasHeaders: hasHeaders, rows: preview.firstRows })))));\n    }, [preview, hasHeaders, l10n]);\n    if (!selectedFile) {\n        return React.createElement(FileSelector, { onSelected: (file) => setSelectedFile(file) });\n    }\n    return (React.createElement(ImporterFrame, { fileName: selectedFile.name, nextDisabled: !preview || !!preview.parseError || !!preview.parseWarning, onNext: () => {\n            if (!preview || preview.parseError) {\n                throw new Error('unexpected missing preview info');\n            }\n            onAccept();\n        }, onCancel: () => setSelectedFile(null), nextLabel: l10n.nextButton }, reportBlock || (React.createElement(\"div\", { className: \"CSVImporter_FileStep__mainPendingBlock\" }, l10n.previewLoadingStatus))));\n};\n","// spreadsheet-style column code computation (A, B, ..., Z, AA, AB, ..., etc)\nexport function generateColumnCode(value) {\n    // ignore dummy index\n    if (value < 0) {\n        return '';\n    }\n    // first, determine how many base-26 letters there should be\n    // (because the notation is not purely positional)\n    let digitCount = 1;\n    let base = 0;\n    let next = 26;\n    while (next <= value) {\n        digitCount += 1;\n        base = next;\n        next = next * 26 + 26;\n    }\n    // then, apply normal positional digit computation on remainder above base\n    let remainder = value - base;\n    const digits = [];\n    while (digits.length < digitCount) {\n        const lastDigit = remainder % 26;\n        remainder = Math.floor((remainder - lastDigit) / 26); // applying floor just in case\n        // store ASCII code, with A as 0\n        digits.unshift(65 + lastDigit);\n    }\n    return String.fromCharCode.apply(null, digits);\n}\n// prepare spreadsheet-like column display information for given raw data preview\nexport function generatePreviewColumns(firstRows, hasHeaders) {\n    const columnStubs = [...new Array(firstRows[0].length)];\n    return columnStubs.map((empty, index) => {\n        const values = firstRows.map((row) => row[index] || '');\n        const headerValue = hasHeaders ? values.shift() : undefined;\n        return {\n            index,\n            header: headerValue,\n            values\n        };\n    });\n}\n","import { useState, useCallback, useRef } from 'react';\n// state machine to represent the steps taken to assign a column to target field:\n// - pick column (drag start or keyboard select)\n// - hover over field (while dragging only)\n// - assign picked column to field (drag end)\n// @todo move the useDrag setup outside as well?\nexport function useColumnDragState(onColumnAssignment) {\n    // wrap in ref to avoid re-triggering effects\n    const onColumnAssignmentRef = useRef(onColumnAssignment);\n    onColumnAssignmentRef.current = onColumnAssignment;\n    const [dragState, setDragState] = useState(null);\n    const dragStartHandler = useCallback((column, startFieldName, initialClientRect) => {\n        // create new pointer-based drag state\n        setDragState({\n            pointerStartInfo: {\n                initialClientRect\n            },\n            column,\n            dropFieldName: startFieldName !== undefined ? startFieldName : null,\n            updateListeners: []\n        });\n    }, []);\n    const dragMoveHandler = useCallback((movement) => {\n        // @todo figure out a cleaner event stream solution\n        if (dragState) {\n            const listeners = dragState.updateListeners;\n            for (const listener of listeners) {\n                listener(movement);\n            }\n        }\n    }, [dragState]);\n    const dragEndHandler = useCallback(() => {\n        setDragState(null);\n        if (dragState) {\n            onColumnAssignmentRef.current(dragState.column, dragState.dropFieldName);\n        }\n    }, [dragState]);\n    const columnSelectHandler = useCallback((column) => {\n        setDragState((prev) => {\n            // toggle off if needed\n            if (prev && prev.column === column) {\n                return null;\n            }\n            return {\n                pointerStartInfo: null,\n                column,\n                dropFieldName: null,\n                updateListeners: []\n            };\n        });\n    }, []);\n    const dragHoverHandler = useCallback((fieldName, isOn) => {\n        setDragState((prev) => {\n            if (!prev) {\n                return prev;\n            }\n            if (isOn) {\n                // set the new drop target\n                return Object.assign(Object.assign({}, prev), { dropFieldName: fieldName });\n            }\n            else if (prev.dropFieldName === fieldName) {\n                // clear drop target if we are still the current one\n                return Object.assign(Object.assign({}, prev), { dropFieldName: null });\n            }\n            // no changes by default\n            return prev;\n        });\n    }, []);\n    const assignHandler = useCallback((fieldName) => {\n        // clear active drag state\n        setDragState(null);\n        if (dragState) {\n            onColumnAssignmentRef.current(dragState.column, fieldName);\n        }\n    }, [dragState]);\n    const unassignHandler = useCallback((column) => {\n        // clear active drag state\n        setDragState(null);\n        onColumnAssignmentRef.current(column, null);\n    }, []);\n    return {\n        dragState,\n        dragStartHandler,\n        dragMoveHandler,\n        dragEndHandler,\n        dragHoverHandler,\n        columnSelectHandler,\n        assignHandler,\n        unassignHandler\n    };\n}\n","import React, { useMemo } from 'react';\nimport { PREVIEW_ROW_COUNT } from '../../parser';\nimport './ColumnDragCard.scss';\nimport { useLocale } from '../../locale/LocaleContext';\n// @todo sort out \"grabbing\" cursor state (does not work with pointer-events:none)\nexport const ColumnDragCard = ({ hasHeaders, column: optionalColumn, rowCount = PREVIEW_ROW_COUNT, hasError, isAssigned, isShadow, isDraggable, isDragged, isDropIndicator }) => {\n    const isDummy = !optionalColumn;\n    const column = useMemo(() => optionalColumn || {\n        index: -1,\n        code: '',\n        header: hasHeaders ? '' : undefined,\n        values: [...new Array(PREVIEW_ROW_COUNT)].map(() => '')\n    }, [optionalColumn, hasHeaders]);\n    const headerValue = column.header;\n    const dataValues = column.values.slice(0, headerValue === undefined ? rowCount : rowCount - 1);\n    const l10n = useLocale('fieldsStep');\n    return (\n    // not changing variant dynamically because it causes a height jump\n    React.createElement(\"div\", { key: isDummy || isShadow ? 1 : isDropIndicator ? 2 : 0, className: \"CSVImporter_ColumnDragCard\", \"data-dummy\": !!isDummy, \"data-error\": !!hasError, \"data-shadow\": !!isShadow, \"data-draggable\": !!isDraggable, \"data-dragged\": !!isDragged, \"data-drop-indicator\": !!isDropIndicator },\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragCard__cardHeader\" },\n            isDummy ? (React.createElement(\"var\", { role: \"text\" }, l10n.columnCardDummyHeader)) : (React.createElement(\"var\", { role: \"text\" }, l10n.getColumnCardHeader(column.code))),\n            isDummy || isAssigned ? '\\u00a0' : React.createElement(\"b\", { \"aria-hidden\": true }, column.code)),\n        headerValue !== undefined ? (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragCard__cardValue\", \"data-header\": true }, headerValue || '\\u00a0')) : null,\n        React.createElement(\"div\", { role: \"text\" }, dataValues.map((value, valueIndex) => (React.createElement(\"div\", { key: valueIndex, className: \"CSVImporter_ColumnDragCard__cardValue\" }, value || '\\u00a0'))))));\n};\n","import React, { useRef, useLayoutEffect } from 'react';\nimport { createPortal } from 'react-dom';\nimport { ColumnDragCard } from './ColumnDragCard';\nimport './ColumnDragObject.scss';\nexport const ColumnDragObject = ({ dragState }) => {\n    const referenceBoxRef = useRef(null);\n    // the dragged box is wrapped in a no-events overlay to clip against screen edges\n    const dragBoxRef = useRef(null);\n    const dragObjectPortal = dragState && dragState.pointerStartInfo\n        ? createPortal(React.createElement(\"div\", { className: \"CSVImporter_ColumnDragObject__overlay\" },\n            React.createElement(\"div\", { className: \"CSVImporter_ColumnDragObject__positioner\", ref: dragBoxRef },\n                React.createElement(\"div\", { className: \"CSVImporter_ColumnDragObject__holder\" },\n                    React.createElement(ColumnDragCard, { column: dragState.column, isDragged: true })))), document.body)\n        : null;\n    // set up initial position when pointer-based gesture is started\n    const pointerStartInfo = dragState && dragState.pointerStartInfo;\n    useLayoutEffect(() => {\n        // ignore non-pointer drag states\n        if (!pointerStartInfo || !dragBoxRef.current) {\n            return;\n        }\n        // place based on initial position + size relative to viewport overlay\n        const rect = pointerStartInfo.initialClientRect;\n        dragBoxRef.current.style.left = `${rect.left}px`;\n        dragBoxRef.current.style.top = `${rect.top}px`;\n        dragBoxRef.current.style.width = `${rect.width}px`;\n        dragBoxRef.current.style.height = `${rect.height}px`;\n        // copy known cascaded font style from main content into portal content\n        // @todo consider other text style properties?\n        if (referenceBoxRef.current) {\n            const computedStyle = window.getComputedStyle(referenceBoxRef.current);\n            dragBoxRef.current.style.fontFamily = computedStyle.fontFamily;\n            dragBoxRef.current.style.fontSize = computedStyle.fontSize;\n            dragBoxRef.current.style.fontWeight = computedStyle.fontWeight;\n            dragBoxRef.current.style.fontStyle = computedStyle.fontStyle;\n            dragBoxRef.current.style.letterSpacing = computedStyle.letterSpacing;\n        }\n    }, [pointerStartInfo]);\n    // subscribe to live position updates without state changes\n    useLayoutEffect(() => {\n        if (dragState) {\n            const updateListener = (movement) => {\n                if (!dragBoxRef.current)\n                    return;\n                // update the visible offset relative to starting position\n                const [x, y] = movement;\n                dragBoxRef.current.style.transform = `translate(${x}px, ${y}px)`;\n            };\n            dragState.updateListeners.push(updateListener);\n            // clean up listener\n            return () => {\n                const removeIndex = dragState.updateListeners.indexOf(updateListener);\n                if (removeIndex !== -1) {\n                    dragState.updateListeners.splice(removeIndex, 1);\n                }\n            };\n        }\n    }, [dragState]);\n    return React.createElement(\"div\", { ref: referenceBoxRef }, dragObjectPortal);\n};\n","import React, { useState, useMemo } from 'react';\nimport { ColumnDragCard } from './ColumnDragCard';\nimport { IconButton } from '../IconButton';\nimport './ColumnDragSourceArea.scss';\nimport { useLocale } from '../../locale/LocaleContext';\nconst DEFAULT_PAGE_SIZE = 5; // fraction of 10 for easier counting\n// @todo readable status text if not mouse-drag\nconst SourceBox = ({ column, fieldAssignments, dragState, eventBinder, onSelect, onUnassign }) => {\n    const isDragged = dragState ? column === dragState.column : false;\n    const isAssigned = useMemo(() => Object.keys(fieldAssignments).some((fieldName) => fieldAssignments[fieldName] === column.index), [fieldAssignments, column]);\n    const eventHandlers = useMemo(() => eventBinder(column), [\n        eventBinder,\n        column\n    ]);\n    const l10n = useLocale('fieldsStep');\n    return (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__box\" },\n        React.createElement(\"div\", Object.assign({}, (isAssigned ? {} : eventHandlers), { style: { touchAction: 'none' } }),\n            React.createElement(ColumnDragCard, { column: column, isAssigned: isAssigned, isShadow: isDragged || isAssigned, isDraggable: !dragState && !isDragged && !isAssigned })),\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__boxAction\" }, isAssigned ? (React.createElement(IconButton, { key: \"clear\" // key-prop helps clear focus on click\n            , label: l10n.clearAssignmentTooltip, small: true, type: \"replay\", onClick: () => {\n                onUnassign(column);\n            } })) : (React.createElement(IconButton, { key: \"dragSelect\" // key-prop helps clear focus on click\n            , focusOnly: true, label: dragState && dragState.column === column\n                ? l10n.unselectColumnTooltip\n                : l10n.selectColumnTooltip, small: true, type: \"back\", onClick: () => {\n                onSelect(column);\n            } })))));\n};\n// @todo current page indicator (dots)\nexport const ColumnDragSourceArea = ({ columns, columnPageSize, fieldAssignments, dragState, eventBinder, onSelect, onUnassign }) => {\n    // sanitize page size setting\n    const pageSize = Math.round(Math.max(1, columnPageSize !== null && columnPageSize !== void 0 ? columnPageSize : DEFAULT_PAGE_SIZE));\n    // track pagination state (resilient to page size changes)\n    const [pageStart, setPageStart] = useState(0);\n    const [pageChanged, setPageChanged] = useState(false);\n    const page = Math.floor(pageStart / pageSize); // round down in case page size changes\n    const pageCount = Math.ceil(columns.length / pageSize);\n    // display page items and fill up with dummy divs up to pageSize\n    const pageContents = columns\n        .slice(page * pageSize, (page + 1) * pageSize)\n        .map((column, columnIndex) => (React.createElement(SourceBox, { key: columnIndex, column: column, fieldAssignments: fieldAssignments, dragState: dragState, eventBinder: eventBinder, onSelect: onSelect, onUnassign: onUnassign })));\n    while (pageContents.length < pageSize) {\n        pageContents.push(React.createElement(\"div\", { key: pageContents.length, className: \"CSVImporter_ColumnDragSourceArea__pageFiller\" }));\n    }\n    const l10n = useLocale('fieldsStep');\n    return (React.createElement(\"section\", { className: \"CSVImporter_ColumnDragSourceArea\", \"aria-label\": l10n.dragSourceAreaCaption },\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__control\" },\n            React.createElement(IconButton, { label: l10n.previousColumnsTooltip, type: \"back\", disabled: page === 0, onClick: () => {\n                    setPageStart((prev) => Math.max(0, Math.floor(prev / pageSize) - 1) * pageSize);\n                    setPageChanged(true);\n                } })),\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__page\" },\n            dragState && !dragState.pointerStartInfo ? (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__pageIndicator\", role: \"status\" }, l10n.getDragSourceActiveStatus(dragState.column.code))) : (\n            // show page number if needed (and treat as status role if it has changed)\n            // @todo changing role to status does not seem to work\n            pageCount > 1 && (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__pageIndicator\", role: pageChanged ? 'status' : 'text' }, l10n.getDragSourcePageIndicator(page + 1, pageCount)))),\n            pageContents),\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__control\" },\n            React.createElement(IconButton, { label: l10n.nextColumnsTooltip, type: \"forward\", disabled: page >= pageCount - 1, onClick: () => {\n                    setPageStart((prev) => Math.min(pageCount - 1, Math.floor(prev / pageSize) + 1) *\n                        pageSize);\n                } }))));\n};\n","import React, { useMemo, useRef } from 'react';\nimport { ColumnDragCard } from './ColumnDragCard';\nimport { IconButton } from '../IconButton';\nimport './ColumnDragTargetArea.scss';\nimport { useLocale } from '../../locale/LocaleContext';\nconst TargetBox = ({ field, hasHeaders, flexBasis, touched, assignedColumn, dragState, eventBinder, onHover, onAssign, onUnassign }) => {\n    // respond to hover events when there is active mouse drag happening\n    // (not keyboard-emulated one)\n    const containerRef = useRef(null);\n    // if this field is the current highlighted drop target,\n    // get the originating column data for display\n    const sourceColumn = dragState && dragState.dropFieldName === field.name\n        ? dragState.column\n        : null;\n    // see if currently assigned column is being dragged again\n    const isReDragged = dragState ? dragState.column === assignedColumn : false;\n    // drag start handlers for columns that can be re-dragged (i.e. are assigned)\n    const dragStartHandlers = useMemo(() => assignedColumn && !isReDragged\n        ? eventBinder(assignedColumn, field.name)\n        : {}, [eventBinder, assignedColumn, isReDragged, field.name]);\n    const valueContents = useMemo(() => {\n        if (sourceColumn) {\n            return (React.createElement(ColumnDragCard, { rowCount: 3, column: sourceColumn, isDropIndicator: true }));\n        }\n        if (assignedColumn) {\n            return (React.createElement(ColumnDragCard, { rowCount: 3, column: assignedColumn, isShadow: isReDragged, isDraggable: !isReDragged }));\n        }\n        const hasError = touched && !field.isOptional;\n        return (React.createElement(ColumnDragCard, { rowCount: 3, hasHeaders: hasHeaders, hasError: hasError }));\n    }, [hasHeaders, field, touched, assignedColumn, sourceColumn, isReDragged]);\n    const l10n = useLocale('fieldsStep');\n    // @todo mouse cursor changes to reflect draggable state\n    return (React.createElement(\"section\", { className: \"CSVImporter_ColumnDragTargetArea__box\", \"aria-label\": field.isOptional\n            ? l10n.getDragTargetOptionalCaption(field.label)\n            : l10n.getDragTargetRequiredCaption(field.label), ref: containerRef, style: { flexBasis }, onPointerEnter: () => onHover(field.name, true), onPointerLeave: () => onHover(field.name, false) },\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxLabel\", \"aria-hidden\": true },\n            field.label,\n            field.isOptional ? null : React.createElement(\"b\", null, \"*\")),\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxValue\" },\n            !sourceColumn && !assignedColumn && (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxPlaceholderHelp\", \"aria-hidden\": true }, l10n.dragTargetPlaceholder)),\n            React.createElement(\"div\", Object.assign({}, dragStartHandlers, { style: { touchAction: 'none' } }), valueContents),\n            dragState && !dragState.pointerStartInfo ? (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxValueAction\" },\n                React.createElement(IconButton, { label: l10n.getDragTargetAssignTooltip(dragState.column.code), small: true, type: \"forward\", onClick: () => onAssign(field.name) }))) : (!sourceColumn &&\n                assignedColumn && (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxValueAction\" },\n                React.createElement(IconButton, { label: l10n.dragTargetClearTooltip, small: true, type: \"close\", onClick: () => onUnassign(assignedColumn) })))))));\n};\nexport const ColumnDragTargetArea = ({ hasHeaders, fields, columns, fieldRowSize, fieldTouched, fieldAssignments, dragState, eventBinder, onHover, onAssign, onUnassign }) => {\n    const l10n = useLocale('fieldsStep');\n    // override flex basis for unusual situations\n    const flexBasis = fieldRowSize ? `${100 / fieldRowSize}%` : undefined;\n    return (React.createElement(\"section\", { className: \"CSVImporter_ColumnDragTargetArea\", \"aria-label\": l10n.dragTargetAreaCaption }, fields.map((field) => {\n        const assignedColumnIndex = fieldAssignments[field.name];\n        return (React.createElement(TargetBox, { key: field.name, field: field, flexBasis: flexBasis, touched: fieldTouched[field.name], hasHeaders: hasHeaders, assignedColumn: assignedColumnIndex !== undefined\n                ? columns[assignedColumnIndex]\n                : null, dragState: dragState, eventBinder: eventBinder, onHover: onHover, onAssign: onAssign, onUnassign: onUnassign }));\n    })));\n};\n","import React, { useState, useMemo, useEffect, useRef } from 'react';\nimport { useDrag } from '@use-gesture/react';\nimport { ImporterFrame } from '../ImporterFrame';\nimport { generatePreviewColumns, generateColumnCode } from './ColumnPreview';\nimport { useColumnDragState } from './ColumnDragState';\nimport { ColumnDragObject } from './ColumnDragObject';\nimport { ColumnDragSourceArea } from './ColumnDragSourceArea';\nimport { ColumnDragTargetArea } from './ColumnDragTargetArea';\nimport { useLocale } from '../../locale/LocaleContext';\nexport const FieldsStep = ({ fields, displayColumnPageSize, displayFieldRowSize, fileState, prevState, onChange, onAccept, onCancel }) => {\n    const l10n = useLocale('fieldsStep');\n    const onChangeRef = useRef(onChange);\n    onChangeRef.current = onChange;\n    const columns = useMemo(() => generatePreviewColumns(fileState.firstRows, fileState.hasHeaders).map((item) => (Object.assign(Object.assign({}, item), { code: generateColumnCode(item.index) }))), [fileState]);\n    // field assignments state\n    const [fieldAssignments, setFieldAssignments] = useState(prevState ? prevState.fieldAssignments : {});\n    // make sure there are no extra fields\n    useEffect(() => {\n        const removedFieldNames = Object.keys(fieldAssignments).filter((existingFieldName) => !fields.some((field) => field.name === existingFieldName));\n        if (removedFieldNames.length > 0) {\n            // @todo put everything inside this setter\n            setFieldAssignments((prev) => {\n                const copy = Object.assign({}, prev);\n                removedFieldNames.forEach((fieldName) => {\n                    delete copy[fieldName];\n                });\n                return copy;\n            });\n        }\n    }, [fields, fieldAssignments]);\n    // for any field, try to find an automatic match from known column names\n    useEffect(() => {\n        var _a;\n        // prep insensitive/fuzzy match stems for known columns\n        const columnStemMap = {};\n        for (const column of columns) {\n            const stem = ((_a = column.header) === null || _a === void 0 ? void 0 : _a.trim().toLowerCase()) || undefined;\n            if (stem) {\n                columnStemMap[stem] = column.index;\n            }\n        }\n        setFieldAssignments((prev) => {\n            // prepare a lookup of already assigned columns\n            const assignedColumns = columns.map(() => false);\n            for (const fieldName of Object.keys(prev)) {\n                const assignedColumnIndex = prev[fieldName];\n                if (assignedColumnIndex !== undefined) {\n                    assignedColumns[assignedColumnIndex] = true;\n                }\n            }\n            // augment with new auto-assignments\n            const copy = Object.assign({}, prev);\n            for (const field of fields) {\n                // ignore if field is already assigned\n                if (copy[field.name] !== undefined) {\n                    continue;\n                }\n                // find by field stem\n                const fieldLabelStem = field.label.trim().toLowerCase(); // @todo consider normalizing other whitespace/non-letters\n                const matchingColumnIndex = columnStemMap[fieldLabelStem];\n                // ignore if equivalent column not found\n                if (matchingColumnIndex === undefined) {\n                    continue;\n                }\n                // ignore if column is already assigned\n                if (assignedColumns[matchingColumnIndex]) {\n                    continue;\n                }\n                // auto-assign the column\n                copy[field.name] = matchingColumnIndex;\n            }\n            return copy;\n        });\n    }, [fields, columns]);\n    // track which fields need to show validation warning\n    const [fieldTouched, setFieldTouched] = useState({});\n    const [validationError, setValidationError] = useState(null);\n    // clean up touched field map when dynamic field list changes\n    useEffect(() => {\n        setFieldTouched((prev) => {\n            const result = {};\n            for (const field of fields) {\n                result[field.name] = prev[field.name];\n            }\n            return result;\n        });\n    }, [fields]);\n    // abstract mouse drag/keyboard state tracker\n    const { dragState, dragStartHandler, dragMoveHandler, dragEndHandler, dragHoverHandler, columnSelectHandler, assignHandler, unassignHandler } = useColumnDragState((column, fieldName) => {\n        // update field assignment map state\n        setFieldAssignments((prev) => {\n            const currentFieldName = Object.keys(prev).find((fieldName) => prev[fieldName] === column.index);\n            // see if there is nothing to do\n            if (currentFieldName === undefined && fieldName === null) {\n                return prev;\n            }\n            const copy = Object.assign({}, prev);\n            // ensure dropped column does not show up elsewhere\n            if (currentFieldName) {\n                delete copy[currentFieldName];\n            }\n            // set new field column\n            if (fieldName !== null) {\n                copy[fieldName] = column.index;\n            }\n            return copy;\n        });\n        // mark for validation display\n        if (fieldName) {\n            setFieldTouched((prev) => {\n                if (prev[fieldName]) {\n                    return prev;\n                }\n                return Object.assign(Object.assign({}, prev), { [fieldName]: true });\n            });\n        }\n    });\n    // drag gesture wire-up\n    const bindDrag = useDrag(({ first, last, movement, xy, args, currentTarget }) => {\n        if (first) {\n            const [column, startFieldName] = args;\n            const initialClientRect = currentTarget instanceof HTMLElement\n                ? currentTarget.getBoundingClientRect()\n                : new DOMRect(xy[0], xy[1], 0, 0); // fall back on just pointer position\n            dragStartHandler(column, startFieldName, initialClientRect);\n        }\n        else if (last) {\n            dragEndHandler();\n        }\n        else {\n            dragMoveHandler(movement);\n        }\n    }, {\n        pointer: { capture: false } // turn off pointer capture to avoid interfering with hover tests\n    });\n    // when dragging, set root-level user-select:none to prevent text selection, see Importer.scss\n    // (done via class toggle to avoid interfering with any other dynamic style changes)\n    useEffect(() => {\n        if (dragState) {\n            document.body.classList.add('CSVImporter_dragging');\n        }\n        else {\n            // remove text selection prevention after a delay (otherwise on iOS it still selects something)\n            const timeoutId = setTimeout(() => {\n                document.body.classList.remove('CSVImporter_dragging');\n            }, 200);\n            return () => {\n                // if another drag state comes along then cancel our delay and just clean up class right away\n                clearTimeout(timeoutId);\n                document.body.classList.remove('CSVImporter_dragging');\n            };\n        }\n    }, [dragState]);\n    // notify of current state\n    useEffect(() => {\n        onChangeRef.current({ fieldAssignments: Object.assign({}, fieldAssignments) });\n    }, [fieldAssignments]);\n    return (React.createElement(ImporterFrame, { fileName: fileState.file.name, subtitle: l10n.stepSubtitle, error: validationError, onCancel: onCancel, onNext: () => {\n            // mark all fields as touched (to show all the errors now)\n            const fullTouchedMap = {};\n            fields.forEach((field) => {\n                fullTouchedMap[field.name] = true;\n            });\n            setFieldTouched(fullTouchedMap);\n            // submit if validation succeeds\n            const hasUnassignedRequired = fields.some((field) => !field.isOptional && fieldAssignments[field.name] === undefined);\n            if (!hasUnassignedRequired) {\n                onAccept();\n            }\n            else {\n                setValidationError(l10n.requiredFieldsError);\n            }\n        }, nextLabel: l10n.nextButton },\n        React.createElement(ColumnDragSourceArea, { columns: columns, columnPageSize: displayColumnPageSize, fieldAssignments: fieldAssignments, dragState: dragState, eventBinder: bindDrag, onSelect: columnSelectHandler, onUnassign: unassignHandler }),\n        React.createElement(ColumnDragTargetArea, { hasHeaders: fileState.hasHeaders, fieldRowSize: displayFieldRowSize, fields: fields, columns: columns, fieldTouched: fieldTouched, fieldAssignments: fieldAssignments, dragState: dragState, eventBinder: bindDrag, onHover: dragHoverHandler, onAssign: assignHandler, onUnassign: unassignHandler }),\n        React.createElement(ColumnDragObject, { dragState: dragState })));\n};\n","import React, { useState, useEffect, useMemo, useRef } from 'react';\nimport { processFile } from '../parser';\nimport { ImporterFrame } from './ImporterFrame';\nimport './ProgressDisplay.scss';\nimport { useLocale } from '../locale/LocaleContext';\n// compute actual UTF-8 bytes used by a string\n// (inspired by https://stackoverflow.com/questions/10576905/how-to-convert-javascript-unicode-notation-code-to-utf-8)\nfunction countUTF8Bytes(item) {\n    // re-encode into UTF-8\n    const escaped = encodeURIComponent(item);\n    // convert byte escape sequences into single characters\n    const normalized = escaped.replace(/%\\d\\d/g, '_');\n    return normalized.length;\n}\nexport function ProgressDisplay({ fileState, fieldsState, externalPreview, dataHandler, onStart, onComplete, onRestart, onClose }) {\n    const [progressCount, setProgressCount] = useState(0);\n    const [isComplete, setIsComplete] = useState(false);\n    const [error, setError] = useState(null);\n    const [isDismissed, setIsDismissed] = useState(false); // prevents double-clicking finish\n    // info object exposed to the progress callbacks\n    const importInfo = useMemo(() => {\n        const fieldList = Object.keys(fieldsState.fieldAssignments);\n        const columnSparseList = [];\n        fieldList.forEach((field) => {\n            const col = fieldsState.fieldAssignments[field];\n            if (col !== undefined) {\n                columnSparseList[col] = field;\n            }\n        });\n        return {\n            file: fileState.file,\n            preview: externalPreview,\n            fields: fieldList,\n            columnFields: [...columnSparseList]\n        };\n    }, [fileState, fieldsState, externalPreview]);\n    // estimate number of rows\n    const estimatedRowCount = useMemo(() => {\n        // sum up sizes of all the parsed preview rows and get estimated average\n        const totalPreviewRowBytes = fileState.firstRows.reduce((prevCount, row) => {\n            const rowBytes = row.reduce((prev, item) => {\n                return prev + countUTF8Bytes(item) + 1; // add a byte for separator or newline\n            }, 0);\n            return prevCount + rowBytes;\n        }, 0);\n        const averagePreviewRowSize = totalPreviewRowBytes / fileState.firstRows.length;\n        // divide file size by estimated row size (or fall back to a sensible amount)\n        return averagePreviewRowSize > 1\n            ? fileState.file.size / averagePreviewRowSize\n            : 100;\n    }, [fileState]);\n    // notify on start of processing\n    // (separate effect in case of errors)\n    const onStartRef = useRef(onStart); // wrap in ref to avoid re-triggering (only first instance is needed)\n    useEffect(() => {\n        if (onStartRef.current) {\n            onStartRef.current(importInfo);\n        }\n    }, [importInfo]);\n    // notify on end of processing\n    // (separate effect in case of errors)\n    const onCompleteRef = useRef(onComplete); // wrap in ref to avoid re-triggering\n    onCompleteRef.current = onComplete;\n    useEffect(() => {\n        if (isComplete && onCompleteRef.current) {\n            onCompleteRef.current(importInfo);\n        }\n    }, [importInfo, isComplete]);\n    // ensure status gets focus when complete, in case status role is not read out\n    const statusRef = useRef(null);\n    useEffect(() => {\n        if ((isComplete || error) && statusRef.current) {\n            statusRef.current.focus();\n        }\n    }, [isComplete, error]);\n    // trigger processing from an effect to mitigate React 18 double-run in dev\n    const [ready, setReady] = useState(false);\n    useEffect(() => {\n        setReady(true);\n    }, []);\n    // perform main async parse\n    const dataHandlerRef = useRef(dataHandler); // wrap in ref to avoid re-triggering\n    const asyncLockRef = useRef(0);\n    useEffect(() => {\n        // avoid running on first render due to React 18 double-run\n        if (!ready) {\n            return;\n        }\n        const oplock = asyncLockRef.current;\n        processFile(Object.assign(Object.assign({}, fileState), { fieldAssignments: fieldsState.fieldAssignments }), (deltaCount) => {\n            // ignore if stale\n            if (oplock !== asyncLockRef.current) {\n                return; // @todo signal abort\n            }\n            setProgressCount((prev) => prev + deltaCount);\n        }, dataHandlerRef.current).then(() => {\n            // ignore if stale\n            if (oplock !== asyncLockRef.current) {\n                return;\n            }\n            setIsComplete(true);\n        }, (error) => {\n            // ignore if stale\n            if (oplock !== asyncLockRef.current) {\n                return;\n            }\n            setError(error);\n        });\n        return () => {\n            // invalidate current oplock on change or unmount\n            asyncLockRef.current += 1;\n        };\n    }, [ready, fileState, fieldsState]);\n    // simulate asymptotic progress percentage\n    const progressPercentage = useMemo(() => {\n        if (isComplete) {\n            return 100;\n        }\n        // inputs hand-picked so that correctly estimated total is about 75% of the bar\n        const progressPower = 2.5 * (progressCount / estimatedRowCount);\n        const progressLeft = Math.pow(0.5, progressPower);\n        // convert to .1 percent precision for smoother bar display\n        return Math.floor(1000 - 1000 * progressLeft) / 10;\n    }, [estimatedRowCount, progressCount, isComplete]);\n    const l10n = useLocale('progressStep');\n    return (React.createElement(ImporterFrame, { fileName: fileState.file.name, subtitle: l10n.stepSubtitle, error: error && (error.message || String(error)), secondaryDisabled: !isComplete || isDismissed, secondaryLabel: onRestart && onClose ? l10n.uploadMoreButton : undefined, onSecondary: onRestart && onClose ? onRestart : undefined, nextDisabled: !isComplete || isDismissed, nextLabel: !!(onClose || onRestart) &&\n            (onClose ? l10n.finishButton : l10n.uploadMoreButton), onNext: () => {\n            if (onClose) {\n                setIsDismissed(true);\n                onClose(importInfo);\n            }\n            else if (onRestart) {\n                onRestart();\n            }\n        } },\n        React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay\" },\n            isComplete || error ? (React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__status\", role: \"status\", tabIndex: -1, ref: statusRef }, error ? l10n.statusError : l10n.statusComplete)) : (React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__status -pending\", role: \"status\" }, l10n.statusPending)),\n            React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__count\", role: \"text\" },\n                React.createElement(\"var\", null, l10n.processedRowsLabel),\n                \" \",\n                progressCount),\n            React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__progressBar\" },\n                React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__progressBarIndicator\", style: { width: `${progressPercentage}%` } })))));\n}\n","import React, { useMemo, useState, useEffect, useContext } from 'react';\nconst FieldDefinitionContext = React.createContext(null);\n// internal helper to allow user code to provide field definitions\nexport function useFieldDefinitions() {\n    const [fields, setFields] = useState([]);\n    const userFieldContentWrapper = (content) => (React.createElement(FieldDefinitionContext.Provider, { value: setFields }, content));\n    return [fields, userFieldContentWrapper];\n}\n// defines a field to be filled from file column during import\nexport const ImporterField = ({ name, label, optional }) => {\n    // make unique internal ID (this is never rendered in HTML and does not affect SSR)\n    const instanceId = useMemo(() => Symbol('internal unique field ID'), []);\n    const fieldSetter = useContext(FieldDefinitionContext);\n    // update central list as needed\n    useEffect(() => {\n        if (!fieldSetter) {\n            console.error('importer field must be a child of importer'); // @todo\n            return;\n        }\n        fieldSetter((prev) => {\n            const copy = [...prev];\n            const existingIndex = copy.findIndex((item) => item.instanceId === instanceId);\n            // add or update the field definition instance in-place\n            // (using internal field instance ID helps gracefully tolerate duplicates, renames, etc)\n            const newField = {\n                instanceId,\n                name,\n                label,\n                isOptional: !!optional\n            };\n            if (existingIndex === -1) {\n                copy.push(newField);\n            }\n            else {\n                copy[existingIndex] = newField;\n            }\n            return copy;\n        });\n    }, [instanceId, fieldSetter, name, label, optional]);\n    // on component unmount, remove this field from list by ID\n    useEffect(() => {\n        if (!fieldSetter) {\n            console.error('importer field must be a child of importer'); // @todo\n            return;\n        }\n        return () => {\n            fieldSetter((prev) => prev.filter((field) => field.instanceId !== instanceId));\n        };\n    }, [instanceId, fieldSetter]);\n    return null;\n};\n","var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport React, { useMemo, useState, useEffect } from 'react';\nimport { FileStep } from './file-step/FileStep';\nimport { generatePreviewColumns } from './fields-step/ColumnPreview';\nimport { FieldsStep } from './fields-step/FieldsStep';\nimport { ProgressDisplay } from './ProgressDisplay';\n// re-export from a central spot\nexport { ImporterField } from './ImporterField';\nimport { useFieldDefinitions } from './ImporterField';\nimport './Importer.scss';\nimport { LocaleContext } from '../locale/LocaleContext';\nimport { enUS } from '../locale';\nexport function Importer(props) {\n    const { dataHandler, processChunk, defaultNoHeader, assumeNoHeaders, restartable, displayFieldRowSize, displayColumnPageSize, onStart, onComplete, onClose, children: content, locale: userLocale } = props, customPapaParseConfig = __rest(props, [\"dataHandler\", \"processChunk\", \"defaultNoHeader\", \"assumeNoHeaders\", \"restartable\", \"displayFieldRowSize\", \"displayColumnPageSize\", \"onStart\", \"onComplete\", \"onClose\", \"children\", \"locale\"]);\n    // helper to combine our displayed content and the user code that provides field definitions\n    const [fields, userFieldContentWrapper] = useFieldDefinitions();\n    const [fileState, setFileState] = useState(null);\n    const [fileAccepted, setFileAccepted] = useState(false);\n    const [fieldsState, setFieldsState] = useState(null);\n    const [fieldsAccepted, setFieldsAccepted] = useState(false);\n    // reset field assignments when file changes\n    const activeFile = fileState && fileState.file;\n    useEffect(() => {\n        if (activeFile) {\n            setFieldsState(null);\n        }\n    }, [activeFile]);\n    const externalPreview = useMemo(() => {\n        // generate stable externally-visible data objects\n        const externalColumns = fileState &&\n            generatePreviewColumns(fileState.firstRows, fileState.hasHeaders);\n        return (fileState &&\n            externalColumns && {\n            rawData: fileState.firstChunk,\n            columns: externalColumns,\n            skipHeaders: !fileState.hasHeaders,\n            parseWarning: fileState.parseWarning\n        });\n    }, [fileState]);\n    // fall back to enUS if no locale provided\n    const locale = userLocale !== null && userLocale !== void 0 ? userLocale : enUS;\n    if (!fileAccepted || fileState === null || externalPreview === null) {\n        return (React.createElement(LocaleContext.Provider, { value: locale },\n            React.createElement(\"div\", { className: \"CSVImporter_Importer\" },\n                React.createElement(FileStep, { customConfig: customPapaParseConfig, defaultNoHeader: defaultNoHeader !== null && defaultNoHeader !== void 0 ? defaultNoHeader : assumeNoHeaders, prevState: fileState, onChange: (parsedPreview) => {\n                        setFileState(parsedPreview);\n                    }, onAccept: () => {\n                        setFileAccepted(true);\n                    } }))));\n    }\n    if (!fieldsAccepted || fieldsState === null) {\n        return (React.createElement(LocaleContext.Provider, { value: locale },\n            React.createElement(\"div\", { className: \"CSVImporter_Importer\" },\n                React.createElement(FieldsStep, { fileState: fileState, fields: fields, prevState: fieldsState, displayFieldRowSize: displayFieldRowSize, displayColumnPageSize: displayColumnPageSize, onChange: (state) => {\n                        setFieldsState(state);\n                    }, onAccept: () => {\n                        setFieldsAccepted(true);\n                    }, onCancel: () => {\n                        // keep existing preview data and assignments\n                        setFileAccepted(false);\n                    } }),\n                userFieldContentWrapper(\n                // render the provided child content that defines the fields\n                typeof content === 'function'\n                    ? content({\n                        file: fileState && fileState.file,\n                        preview: externalPreview\n                    })\n                    : content))));\n    }\n    return (React.createElement(LocaleContext.Provider, { value: locale },\n        React.createElement(\"div\", { className: \"CSVImporter_Importer\" },\n            React.createElement(ProgressDisplay, { fileState: fileState, fieldsState: fieldsState, externalPreview: externalPreview, \n                // @todo remove assertion after upgrading to TS 4.1+\n                dataHandler: dataHandler !== null && dataHandler !== void 0 ? dataHandler : processChunk, onStart: onStart, onRestart: restartable\n                    ? () => {\n                        // reset all state\n                        setFileState(null);\n                        setFileAccepted(false);\n                        setFieldsState(null);\n                        setFieldsAccepted(false);\n                    }\n                    : undefined, onComplete: onComplete, onClose: onClose }))));\n}\n","export * from './components/ImporterProps';\nexport * from './components/Importer';\nexport * from './locale';\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aA2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aA2CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnoDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5YA;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClFA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACrQA;AACA;AACA;AACA;AACA;AACA;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/CA;AACA;AACA;AACA;AACA;AACA;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7FA;AACA;AACA;;;;A","sourceRoot":""}